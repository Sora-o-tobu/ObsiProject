# Chapter 4. Processor Architecture

!!! quote
	指令系统是计算机软件和硬件的交互接口，程序员根据指令系统设计软件，处理器设计人员根据指令系统来实现硬件。

## 从Y86-64讲起

由于`x86-64`指令系统较为复杂，为方便学习和理解，CSAPP原书中参照`x86-64`的指令系统，自定义了一个相对简单的指令系统——`Y86-64`，该指令系统定义包括：

- **Programmer-Visible State** 程序员可见状态
- **Y86-64 Instructions** 指令集
- **Instruction Encoding** 指令集的编码
- **Y86-64 Exceptions** 编程规范以及异常事件处理

### Programmmer-Visible State

程序员可见，这里的 Programmer 既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器；可见状态是指每条指令都会去读取或者修改处理器的某些部分，例如内存、寄存器、条件码、程序计数器以及程序状态等

在`Y86-64`指令系统中，定义了15个64位的程序寄存器，相对于`x86-64`少了一个寄存器`%r15`，主要是为了降低指令编码的复杂度

除此之外，`Y86-64`的指令系统还简化了条件码寄存器，仅保留了零标志(ZF)、符号标志(SF)和溢出标志(OF)

!!! info "复习一下：程序计数器`PC`用来存放当前正在执行指令的地址"

### Y86-64 Instructions

类比`x86`，`Y86`对其指令集做了一定程度的简化，例如将`movq`指令按照源操作数和目的操作数的类型分为了四类：

|            | Source    | Destinination |
| ---------- | --------- | ------------- |
| **rrmovq** | Register  | Register      |
| **Irmovq** | Immediate | Register      |
| **rmmovq** | Register  | Memory        |
| **mrmovq** | Memory    | Register      |

这样设计的目的主要是为了降低处理器实现的复杂度

### Instruction Encoding

接下来我们对上述数据传送指令进行编码，每条指令的第一个字节表示指令的类型。这个字节分为两部分，每一部分占四个比特位：高四位表示指令代码，低四位表示指令功能

![[y86指令编码.png]]

对于上述定义的数据传送指令，不同的指令代码表示不同的指令，指令的功能部分均为 0

在 `Y86` 系统中定义了15个寄存器，虽然每个寄存器有着不同名字，但是还需要为每一个寄存器指定一个编号，用十六进制数 `0~0xE`来表示。如果指令中某个寄存器字段的值为`0xF`，表示此处没有寄存器操作数。

!!! info "寄存器编号"
	![[y86寄存器编号.png]]

在`Y86-64`指令系统中，定义了四条整数操作指令，不同于`x86`，它们只能对寄存器数据进行操作。由于这四条指令属于同一个类型，所以指令代码是一样的，不同的是功能部分：

![[y86整数操作指令.png]]

=== "跳转指令"
	![[y86跳转指令.png]]
=== "条件传送指令"
	条件传送指令一共有 6 条，它与数据传送指令`rrmovq`有相同的指令代码
	
	![[y86条件传送指令.png]]
=== "Other"
	停止指令 **halt** 可以使整个系统暂停运行； **nop** 指令表示一个空操作； **call** 指令和 **ret** 指令分别实现函数调用与返回； **push** 指令和 **pop** 指令分别实现入栈和出栈操作 
	
	![[y86其它指令.png.png]]

综上所述，`Y86-64`的指令集及其编码的定义介绍完毕

---

根据上述的编码规则，可以将`Y86-64`的汇编代码翻译成二进制表示：

例如，对于指令 `rmmovq %rsp, 0x123456789abcd(%rdx)` 

- `rmmovq` → `0x40`
- `%rsp|%rdx` → `0x42`
- `0x123456789abcd` → `0xcdab896745230100`
	- 通过在前面添加 0 来补齐八个字节
	- `x86-64`采用小端法存储，所以需要对偏移量进行字节反序操作

最终得到长度为十个字节的二进制指令：

```
Result:
+--+--+--+--+--+--+--+--+--+--+
|40|42|cd|ab|89|67|45|23|01|00|
+--+--+--+--+--+--+--+--+--+--+
```

接下来通过一个例子看一下C程序翻译成`Y86-64`汇编代码：

```c
long sum(long *start, long count) {
	long sum = 0;
	while (count) {
		sum += *start;
		start++;
		count--;
	}
	return sum;
}
```

那么其可以在`Y86-64`下运行的汇编代码及机器码如下：

![[一个C程序对应的汇编及机器码.png]]

### Y86-64 Exceptions


| Value | Name | Meaning                         | Explanation             |
| ----- | ---- | ------------------------------- | ----------------------- |
| 1     | AOK  | Normal operation                | 程序正常执行                  |
| 2     | HLT  | halt instruction encountered    | 处理器执行 halt 命令           |
| 3     | ADR  | Invalid address encountered     | 程序试图从非法地址读取数据或向非法地址写入数据 |
| 4     | INS  | Invalid instruction encountered | 程序遇到非法指令                |

## 数字电路与处理器设计

对于寄存器堆 (Register File) ，其抽象建模如下：

![[寄存器堆建模.png]]

使用 Verilog 对该寄存器文件进行描述，代码如下：

```verilog
module regfile (
	output reg[63:0] data_out,
	input wire[63:0] data_in,
	input wire[3:0] addr,
	input wire clock,we_,reset_ //we_: write,enable
);
	reg[63:0] regfile[14:0]; //共有十五个寄存器
	assign data_out = regfile[addr];
	...
endmodule
```

寄存器堆具体构造如下，详情请自行学习浙江大学《数字逻辑设计》，讲的内容还是相当优质的。

![[寄存器堆0.png]]

详情可以了解相关章节笔记： [CH 7. Memory Basics - Nimisora's Notes](https://www.nimisora.top/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/Chapter%207%20Memory%20Basics/)

## Y86-64 的顺序实现

!!! quote "第四章的主要内容是设计一个`Y86-64`的处理器，用它来执行上面生成的二进制指令"

通常，处理器执行一条指令的操作可以被组织成六个基本阶段：

- 取指阶段 **Fetch**
	- 指令的长度并不是固定的，需要在取指阶段进行判断
	- 取指阶段会根据指令代码判断指令是否含有寄存器指示符以及是否含有常数，从而计算出当前指令的指令长度
- 译码阶段 **Decode**
	- 译码阶段即从寄存器堆中读取数据
- 执行阶段 **Execute**
	- 执行算数逻辑运算
	- 计算内存引用的有效地址
	- `push` & `pop`
- 访存阶段 **Memory**
	- 既可以从内存中读取数据，也可以将数据写入内存
- 写回阶段 **Write Back**
	- 与译码阶段相反，将数据写入寄存器堆中
- 更新PC **Update**
	- 将PC设置成下一条指令的地址

!!! warning "并不是所有指令执行都要经过上述六个阶段"

例如，处理器处理一个减法指令的具体过程如下：

![[减法指令的六个阶段.png]]

- **Fetch**: 减法指令的两个操作数都为寄存器，因此可以算出当前指令的长度为 2 bytes
- **Decode**: 根据指令，从寄存器堆中读取寄存器数据
- **Execute**: ALU 根据读取的数据执行算数逻辑运算，并根据结果设置条件码寄存器 `CC`
- **Memory**: 由于该指令不需要读写内存，因此访存阶段没有任何操作
- **Write Back**: 写回阶段将 ALU 的运算结果写回到寄存器 `%rbx` 
- **Update**: 最后对程序计数器 `PC` 进行更新

