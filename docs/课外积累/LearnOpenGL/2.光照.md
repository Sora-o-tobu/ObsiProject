
# 2. 光照

## 基础光照

### 颜色

现实生活中的物体颜色由该物体表面反射的光线决定。之前的例子中我们都默认照射光源为白光，它包含所有的颜色值。

在图形学上，光的反射定律决定的颜色值可以很简单地写作：

```c++
glm::vec3 lightColor(1.0f, 1.0f, 1.0f); // 光源颜色，此处是白光
glm::vec3 toyColor(1.0f, 0.5f, 0.31f); // 物体颜色，此处是珊瑚红
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
```

因此，我们可以简单修改片段着色器，使其最终输出的颜色符合这个定律：

```c++
#version 330 core

out vec4 FragColor;

uniform vec3 lightcolor; // 光源颜色
uniform vec3 objectcolor; // 物体颜色

// 透明度
uniform float alpha = 1.0;

void main()
{
    FragColor = vec4(lightcolor * objectcolor, alpha);
}
```

接下来，我们打算创建一个可见的光源，为了便于对光源进行调整，我们为其设置一个单独的 VAO（VBO 和物体相同，因为我们打算用一个较小的箱子代替光源）：

```c++
	Shader ShaderProgram("shader/light/shader.vs", "shader/light/shader.fs");
	ShaderProgram.use();

	ShaderProgram.setVec3("objectcolor", 1.0f, 0.5f, 0.31f); // 物体为橙色
	ShaderProgram.setVec3("lightcolor", 1.0f, 1.0f, 1.0f); // 光源是白色的

	// 调整物体的顶点数据
	glBindVertexArray(VAO);
	// 把顶点数组复制到缓冲中供OpenGL使用
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	// 设置顶点属性指针
	// position attribute
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	Shader LightShader = Shader("shader/light/shader.vs", "shader/light/lightshader.fs");
	LightShader.use();

	// 调整光源的顶点数据
	glBindVertexArray(lightVAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);
```

??? note "本例的顶点数据，为一个箱子"
	```c++
		float vertices[] = {
		-0.5f, -0.5f, -0.5f,
		 0.5f, -0.5f, -0.5f,
		 0.5f,  0.5f, -0.5f,
		 0.5f,  0.5f, -0.5f,
		-0.5f,  0.5f, -0.5f,
		-0.5f, -0.5f, -0.5f,
		-0.5f, -0.5f,  0.5f,
		 0.5f, -0.5f,  0.5f,
		 0.5f,  0.5f,  0.5f,
		 0.5f,  0.5f,  0.5f,
		-0.5f,  0.5f,  0.5f,
		-0.5f, -0.5f,  0.5f,
		-0.5f,  0.5f,  0.5f,
		-0.5f,  0.5f, -0.5f,
		-0.5f, -0.5f, -0.5f,
		-0.5f, -0.5f, -0.5f,
		-0.5f, -0.5f,  0.5f,
		-0.5f,  0.5f,  0.5f,
		 0.5f,  0.5f,  0.5f,
		 0.5f,  0.5f, -0.5f,
		 0.5f, -0.5f, -0.5f,
		 0.5f, -0.5f, -0.5f,
		 0.5f, -0.5f,  0.5f,
		 0.5f,  0.5f,  0.5f,
		-0.5f, -0.5f, -0.5f,
		 0.5f, -0.5f, -0.5f,
		 0.5f, -0.5f,  0.5f,
		 0.5f, -0.5f,  0.5f,
		-0.5f, -0.5f,  0.5f,
		-0.5f, -0.5f, -0.5f,
		-0.5f,  0.5f, -0.5f,
		 0.5f,  0.5f, -0.5f,
		 0.5f,  0.5f,  0.5f,
		 0.5f,  0.5f,  0.5f,
		-0.5f,  0.5f,  0.5f,
		-0.5f,  0.5f, -0.5f,
	};
	```

在渲染循环中，我们每帧都对物体和光源应用不同的变换矩阵：

```c++
// in render loop:
// 物体
ShaderProgram.use();

glm::mat4 view = glm::mat4(1.0f);
view = camera.GetViewMatrix();
glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);

// ShaderProgram.setMatrix4("model", glm::value_ptr(model));
ShaderProgram.setMatrix4("view", glm::value_ptr(view));
ShaderProgram.setMatrix4("projection", glm::value_ptr(projection));

ShaderProgram.setFloat("alpha", 1.0);
glm::mat4 model = glm::mat4(1.0f);
ShaderProgram.setMatrix4("model", glm::value_ptr(model));
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 36);

// 光源
LightShader.use();
LightShader.setMatrix4("view", glm::value_ptr(view));
LightShader.setMatrix4("projection", glm::value_ptr(projection));
model = glm::mat4(1.0f);
model = glm::translate(model, lightPos);
model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube
LightShader.setMatrix4("model", glm::value_ptr(model));
glBindVertexArray(lightVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);
```

理想的结果如下：

![[light1.gif]]


### 光照模型

光照模型基于我们对现实中的光的理解，例如，Phong Lighting Model 将光分为三个分量：

![[phonglightingmodel1.png]]

- **环境光照 ambient：** 我们定义一个环境光照常量，它会永远给物体一些颜色
- **漫反射 diffuse：** 物体某一部分越是正对光源，它就会越亮
- **镜面反射 specular：** 模拟有光泽物体上的亮点

其中，漫反射和镜面反射光线强度的计算需要该点的法线方向。由于我们使用的是一个简单的 3D 立方体，可以简单地将法线数据加入顶点数据中。

根据 [带法线的顶点数据](https://learnopengl.com/code_viewer.php?code=lighting/basic_lighting_vertex_data) ，我们重新修改顶点属性指针使得着色器能够正确识别数据：

```c++
// 设置物体顶点属性指针
// position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// normal attribute
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

// 设置光源顶点属性指针（光源和物体采用同一个 vertices 数组）
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```

我们需要将某顶点的法线数据和变换后的位置从顶点着色器传输给片段着色器，因此顶点着色器的代码修改为：

```c++
#version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out vec3 Normal;
out vec3 FragPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0f);
    FragPos = (model * vec4(aPos, 1.0f)).xyz;
    Normal = mat3(transpose(inverse(model))) * aNormal;
}
```

!!! warning "矩阵求逆"
	矩阵求逆是一个相当复杂的运算，我们应该尽可能避免在着色器中进行求逆运算。对于一个高效应用来说，最好在外部(CPU)中求出逆矩阵，然后通过 uniform 传入着色器。为了方便学习理解，此处仍然把求逆操作放于着色器内。

而 Phong Lighting Model 下的片段着色器代码为：

```c++
#version 330 core

in vec3 Normal;
in vec3 FragPos;

out vec4 FragColor;

uniform vec3 lightPos; // 光源位置
uniform vec3 lightcolor; // 光源颜色
uniform vec3 objectcolor; // 物体颜色
uniform vec3 viewPos; // 观察者位置

void main()
{
    // ambient
    float ambientStrength = 0.1; // 环境光强度因子
    vec3 ambient = ambientStrength * lightcolor;

    // diffuse
    vec3 norm = normalize(Normal); // 法向量
    vec3 lightDir = normalize(lightPos - FragPos); // 光线方向
    float diff = max(dot(norm, lightDir), 0.0); // 计算漫反射强度
    vec3 diffuse = diff * lightcolor;

    // specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32); // 32: 反光度；反光度越高，高光越小
    vec3 specular = specularStrength * spec * lightcolor;

    vec3 result = (ambient + diffuse + specular) * objectcolor;

    FragColor = vec4(result, 1.0f);
}
```

!!! infp "Gouraud 着色和 Phong 着色"
	早期开发者曾经在顶点着色器中实现光照模型的计算，相比于在片段着色器中计算，光照计算频率要低得多，因此更加高效。但是最终得到的颜色值仅仅有周围几个顶点的颜色线性插值计算，效果不够真实，这种着色称为 Gouraud 着色。
	
	![[differenteffectofshadingmodel.png]]

最终得到效果如下：

![[light2.gif]]

