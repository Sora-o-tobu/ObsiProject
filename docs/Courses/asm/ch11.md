
# Basic I/O Interface

## Hardware Specifications

> chapter 9

Intel 8086 和 8088 硬件都包装有 40-pin dual in-line packages（DIPs），区别在于 8086 的 Data Bus 宽度为 16-bit，8088 的 Data Bus 宽度为 8-bit。

!!! info "因此 8086 能够更有效率地传输 16-bit 数据，接下来我们也都以 8086 为例"

![[ch11_1.png]]

8086 可以运行在以下两种模式，两种模式下不同引脚功能不同，通过 33 pin 口 $MN/\bar{MX}$ 指示，其中低电平表示 Maximum：

- **Minimum Mode:** 最简单、开销最小的模式
	- 所有 Memory 和 I/O 操作的控制信号都由处理器生成
- **Maximum Mode:** 
	- 允许系统使用外部的 coprocessor，例如 8087（floating-point coprocessor）
	- 一些控制信号只能在外部生成，需要外部数据总线控制

此处我们简要介绍一下部分引脚的功能：

- Pin Connections $AD_{15} - AD_0$
	- 当引脚 ALE 为 0 时，表示该总线上为数据信号
	- 当引脚 ALE 为 1 时，表示该总线上为地址信号，包括 Memory Address 和 I/O Port Number
		- 具体是内存还是 I/O 由另一个引脚的值进行判断
- Address Latch Enable $ALE$：只在 Minimum Mode 下有效
- $M/\bar{IO}$：为 0 时表示总线上为 I/O；为 1 时表示总线上为 Memory
	- 在 8088 中正好相反，为 $IO/\bar M$
- Bus High Enable $BHE$：指示数据总线上高字节是否有效
	- 相对有一个引脚 $BLE$，但该信号不需要额外产生，默认等于 $A_0$
- Read Signal $\bar{RD}$：是否允许数据总线从 Memory 或 I/O 设备中读取数据
- Write Line $\bar{WR}$：指示是否正在向 Memory 或 I/O 设备中输出数据
- Interrupt Request $INTR$：如果 INTR 在 IF = 1 时保持高位，8086/8088 将在当前指令完成执行后进入中断确认循环。
- Non-Maskable Interrupt $NMI$：与 INTR 类似，但是不需要检查 IF，即不可屏蔽中断

## Intro to I/O Interface

硬件接口可以根据如下三种依据进行划分：

- Directions of information flow
	- Input Interface
	- Output Interface
- Types of signal
	- Analog Interface
	- Digital Interface
- Types of data transmission
	- Serial Interface
	- Parallel Interface
	- 这里的串行表示按位传输数据，并行表示按大于位（比如字节）传输数据

![[ch11_2.png]]

在设计接口的过程中，我们尝试明确以下问题：

- **<1> 怎么将 I/O 设备连接到 CPU？**
	- 对于输出接口，使用 Latches
	- 对于输入接口，使用 Three State Buffers
- **<2> 怎么为 I/O 设备提供 Address Space？**
	- 有两种 Schemes：Isolated I/O 和 Memory Mapped I/O
- **<3> 怎么执行 I/O Port Decoding？**
	- 这一过程需要涉及信号 Memory Address, BHE, BLE, IORC, IOWC
- **<4> 怎么实现处理器和 I/O 设备的同步？**
	- unconditional transfer, strobing, handshaking, polling, interrupt-driven, channel-based(e.g. DMA)...

**Isolated I/O** 使用 `IN` 和 `OUT` 指令来做数据的传输，这里的 isolated 意指 I/O 地址空间是和内存地址空间隔离的，称为 **port**。

- **Advantage**
	- port 是隔离的，不需要为设备占用 Memory Address
- **Disadvantage**
	- 只能通过 `IN` 和 `OUT` 指令进行数据交换
	- 需要对 I/O Space 额外产生控制信号
	- 需要特定的 I/O Instruction，导致编程更加复杂

而 **Memory-Mapped I/O** 允许任意指令进行数据交换，I/O 设备将共享内存空间：

- **Advantage**
	- I/O 操作速度与访存操作等价
	- 简化了编程难度
- **Disadvantage**
	- 占用了大量 Memory Address，并且可能空间不够寻址所有 I/O 设备
	- 如果一个设备响应时间很慢，它会拖累 CPU 访问内存的时间，导致整体性能下降

!!! note "PC 使用 Isolated I/O，而不使用 Memory-Mapped I/O"

在硬件上，TTL 和 CMOS 是最常见的两种逻辑管，其中 CMOS 由于消耗更少能量、速度更快而得到了更广泛的应用。对于它们的输入和输出的逻辑电平，有如下规定标准：

=== "TTL Logic Levels"
	![[ch11_3.png]]
	
	!!! note "TTL 通常是 5V，但是为了和 CMOS 兼容也有 3.3V 的版本"
=== "CMOS Logic Levels"
	![[ch11_4.png]]
	
	!!! note "CMOS 的 VCC 可以是 5V, 3.3V, 1.8V"

总结得到下表：

![[ch11_5.png]]

上表下方有两个例子，其中左例 TTL 的输出电平不满足 CMOS 的输入电平要求，即 $VOHmin > VIHmin, VOLmax < VILmax$。

对于输入设备，我们只需要保证电平匹配、信号稳定即可得到对应的逻辑信号，通常使用**三态门**作为中介；而输出设备还需要保证电流大小足够驱动输出设备。

实际控制中，我们要通过设置合理的电阻值来获得额定电流，我们以一个 LED 灯为例：

![[ch11_6.png]]

已知该三极管基极和集电极的电流大小比例为 1:100。对于 Logic 1，我们输入的电压幅度在 2.4V - 5V 范围内，因此我们要保证对于 2.4V 的输入也能驱动该 LED 灯，则对基极和集电极的电阻设置计算如上。

更一般的*感性负载*电机设备中存在很多电感，在我们断电瞬间会产生反向电动势。如果不对该反向电动势进行处理，高额电压可能会损坏三极管。为此，我们需要在三极管两端增加稳压管：

![[ch11_7.png]]

对于输出设备，输出的信号还需要进行锁存，因为输出的信号是持续性的。控制信号此时不再接入使能信号，而是接入时钟信号；当我们使用指令 `OUT 38H, AL` 时，时钟信号就会发生一次跳变，将我们输出信号进行锁存保存。

对于打印机等更“智能”的设备，我们还要求 CPU 能够和外部设备进行异步数据传输，常见有如下两种方法：

- **Strobing** 选通，单向控制信号
- **Handshaking** 握手，双向控制信号

<font style="font-weight: 1000;font-size: 20px" color="orange">Strobing</font>

Strobing 分为 source-initiated transfer 和 destination-initiated transfer 两种：

=== "source-initiated transfer"
	![[ch11_8.png]]
	
	- source 先将数据写入 Data Bus，然后设置控制信号 Strobe 为 1
	- destination 读取数据到寄存器中
	- source 设置控制信号 Strobe 为 0
	- source 从 Data Bus 中移除数据
=== "destination-initiated transfer"
	![[ch11_9.png]]
	
	- destination 设置控制信号 Strobe 为 1
	- source 将数据写入 Data Bus
	- destination 捕获到数据并写入寄存器，然后设置控制信号 Strobe 为 0
	- source 从 Data Bus 中移除数据

选通方式好处在于简单，坏处在于难以控制连接时间。

<font style="font-weight: 1000;font-size: 20px" color="orange">Handshaking</font>

现在稍微复杂点的设备都采用双向信号，两条控制线分别用于 Request 和 Reply。

=== "source-initiated transfer"
	![[ch11_10.png]]
	
	- source 先将数据写入 Data Bus，然后设置 request
	- destination 读取数据到寄存器中，然后设置 reply
	- source 从 Data Bus 中移除数据，并且重置 request
	- destination 重置 reply
=== "destination-initiated transfer"
	![[ch11_11.png]]
	
	- destination 设置 request
	- source 将数据写入 Data Bus，然后设置 reply
	- destination 捕获到数据并写入寄存器，然后重置 request
	- source 从 Data Bus 中移除数据，并且重置 reply

如下例子展示了 PC 和一个 Printer 之间的数据交换过程，ASCII 数据被放置在 $D_7- D_0$ 中，向 port `PRINTER` 发送数据就相当于 request；打印机收到数据后设置 port `BUSY` 为 1 就相当于 reply：

![[ch11_12.png]]


## I/O Port Address Decoding

!!! warning "往年没考，今年必考"

![[ch11_13.png]]

!!! note "这里的 `81H` 既决定了端口，又决定了该指令是 I/O 还是 Memory（实际对于 `IN` 和 `OUT` 指令都是 I/O）"

其中最重要的是左侧部分对 I/O Port 地址的译码。CPU 的 I/O 指令可以使用 8-bit 地址，范围为 `00H-FFH`，所以这种指令的地址线只会用到 $A_7 -A_0$。

不过实际上，PC 实际 I/O 端口都是 16-bit 地址（`0-FFFFH`），我们通过寄存器 `DX` 指定端口，理论上会对 $A_{15}- A_0$ 完整解码。

以 8-bit 地址为例，其中高五位用于选择译码器（译码器使能），低三位用于译码输入，相当于一个 3-to-8 Decoder，其结构如本节开始的图中左侧部分所示。

!!! example "根据图识别该设备地址译码的范围"
	只有译码器使能全为 1，才能启用该地址译码器；例如下图要求 $A_3 - A_7$ 为 `11110`（注意非门是一个圈）
	
	![[ch11_16.png]]

??? success "对于 16-bit 的地址，使用硬件 PLD"
	下图是一个可编程硬件，因此 $A_{11}- A_{15}$ 也是作为译码器使能输入进入的
	
	![[ch11_14.png]]

我们的数据总线通常为 16-bit，但往往只有 8-bit 有效。在 16-bit 微处理器（如 80386SX）里：

- 内存是 16-bit data bus → 由 **两个 8-bit memory bank** 组成 (High bank + Low bank)
- **I/O 空间也是一样！** → 由 **两个 8-bit I/O bank** 组成：

|Bank|数据线|地址例子|
|---|---|---|
|**低字节 (Low bank)**|D7–D0|偶数端口 (40h)|
|**高字节 (High bank)**|D15–D8|奇数端口 (41h)|

```asm
OUT  AL, 40H   ; 写低位 bank，BLE = 0，写入  D7-D0
OUT  AL, 41H   ; 写高位 bank，BHE = 0，写入 D15-D8
```

`BHE` 和 `BLE` 是两个写选通信号，其中 `BLE` 直接设置为 $A_0$，对 I/O 设备进行一个 8 位写入必须明确它要写哪一半。而 8-bit I/O Read 不需要这两个信号，CPU 可以直接通过地址最低位 $A_0$ 来选择读取哪个字节：

- **$\overline{BHE}$ (Bus High Enable):** 当该信号为低电平（0）时，表示启用高位数据总线 ($D_{15}-D_8$)。
- **$A_0$ (Address line 0):** 当该信号为低电平（0）时，表示启用低位数据总线 ($D_7-D_0$)。

![[ch11_15.png]]

??? question "为什么 8-bit 写入需要两个信号？"
	因为数据通道和地址通道都是 16-bit 的，即 $AD_{15}- AD_0$，而“写”这一操作具有破坏性，因此不能只靠低位 $A_0$ 的奇偶来判断是高位还是低位。

!!! example
	- 当访问地址 `41H` 时，译码器的输入为 $\overline{BHE}=0, \overline{IOWC}=0, A_0=1$
	- 当访问地址 `40H` 时，译码器的输入为 $\overline{BHE}=1, \overline{IOWC}=0, A_0=0$
	- 但对于 16L8 这种可编程硬件，$O_1 -O_8$ 的输出并不一定是根据 3-to-8 译码器那样直接，只需要知道对于该图如果 $\overline{BHE}$ 置 0 则访问 high bank 即可
	
	![[ch11_17.png]]

??? success "对于 16-bit port（2-byte aligned），一次写入 16-bit 数据，不再需要 $\overline{BHE}$ 和 $A_0$"
	![[ch11_18.png]]


## Programmable Peripheral

本节介绍三个经典的外部可编程器件。

### 82C55

!!! quote
	![[ch11_19.png]]

芯片 82C55 提供了可编程接口：

- 它提供 **24 条可编程 I/O 引脚**，其中 `82` 表示是外部可编程器件，`C` 表示是 CMOS 低功耗版本，`55` 是流水号，通常越大越新
- 分成 **A、B、C 三个端口**，每个端口都是 8-bit，其中 A、B 口用于数据传输，C 口用于控制信号
	- 三个端口资源不平等，其中 Port A 和 Port C 都有 Output Latch/Buffer 以及 Input Buffer，而 Port B 只有 Output/Input Shared Latch/Buffer，因此只有 Group A 可以同时输入输出（运行在 Mode 2 下）
	- 实际处理中将三个端口分为两个 Group 设置：
	- Group A：Port A(`PA7-PA0`) & Half Port C(`PC7-PC4`)
	- Group B：Port B(`PB7-PB0`) & Half Port C(`PC3-PC0`)
- 可以设置为 **不同模式（Mode 0/1/2）**
	- *Mode 0*：Basic I/O Operation（for group A & B）允许设置端口是输入还是输出，但是同时智能做一件事
	- *Mode 1*：Strobe I/O Operation（for group A & B）新增双向选通信号，考虑外部设备状态
	- *Mode 2*：Bidirectional Bus Operation（for group A only）允许同时输入输出
		- 即只有 Group A 允许工作在模式 2 下，Port C 宽度不够让 Group B 也工作在双工下
- 在 PC 里常用来连接 **键盘、并口、扬声器、定时器** 等设备
	- 通过 I/O 端口（如 60H、378H）进行读写
- 需要通过 **A0/A1** 指定访问端口 A/B/C 或控制寄存器
	- 控制寄存器大小为 8-bit，第七位决定了该控制字为 Command Byte A 还是 B，分别用于不同的功能
	- *Command Byte A:* 设置端口 A、B、C 的控制信号
	- *Command Byte B:* 设置端口 C 的具体比特位 
- 只有信号 **CS=0** 才能访问芯片

???+ example "将 82C55 接入 80386SX 微处理器的 Low Bank 的一个例子"
	- 因为只接了 Low Bank，所以每个 Port 相隔 2-Byte，使用 $A_1 A_2$ 接入到 82C55 的选择信号 $A_1 A_0$
	- 接入的 $\overline{CS}$ 信号为 0，才启用 82C55
	- 考试可能会给出一批地址，问你哪些位接入 $\overline{CS}$，哪些位接入 $A_1 A_0$
	
	![[ch11_21.png]]

$A_1 A_0=11$ 地址的 Command Register 既是控制寄存器又是状态寄存器，Bit Position 7 决定了该字节当前工作在 A 模式还是 B 模式：

- **$D_7 = 1$**：模式定义模式（Mode Definition），用于配置 A、B、C 端口的工作模式和输入/输出方向。
	- 3-6 位为 Group A 服务；0-2 位为 Group B 服务
- **$D_7 = 0$**：位置位/复位模式（Bit Set/Reset），专门用于对 Port C 的某一位进行置 1 或清 0 操作。
	- Command Byte B 中 4-6 位为自由项，可以随意设置
	- 在 Mode 1/2 中，Port C 被用来做握手信号，因此只能按位写；在 Mode 0 中允许对 Port C 正字节写

![[ch11_22.png]]

??? abstract "三种模式的交互模式"
	![[ch11_20.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=0</font>

对于只需要数据输出或者只需要数据输入的设备（如投影仪），我们只需要运行在 Mode 0 即可。

我们以点亮 8-digit 七段数码管为例，使用 Port B 作为 8 个数字的使能与刷新信号，使用 Port A 作为每个七段数码管的数据，接线如下：

![[ch11_23.png]]

观察我们可以得知，Port A 和 Port B 此时都运行在 Mode 0，输出模式下，因此我们对 Command Register 进行设置：

```asm
; programming the 82C55 PIA
MOV AL, 10000000B    ; command (A) 此时 Port C 相关可以随意设置
MOV DX, 703H         ; address port 703H
OUT DX, AL           ; send command to port 703H
```

接下来，我们循环扫描 8 个数字，以达成所有数字同时亮着的视觉效果：

```asm
DISP PROC NEAR USES AX BX DX SI

	PUSHF                   ; 在循环移位中会影响 Flag，因此要保存恢复
	MOV   BX, 8             ; 计数器 Counter
	MOV   AH, 7FH           ; 选择模式，7F 表示第七个 LED 被选中
	MOV   SI, OFFSET MEM - 1; Display Data 的地址（偏移）
	MOV   DX, 701H          ; Port B 的地址 

; DISPLAY ALL 8 DIGITS

	.REPEAT
		MOV   AL, AH        ;  
		OUT   DX, AL        ; 发送选择模式给 Port B
		DEC   DX            ; Port A 的地址
		MOV   AL, [BX+SI]   ;
		OUT   DX, AL        ; 发送数据给 Port A
		CALL  DELAY         ; 延迟等待 1ms
		ROR   AH, 1         ; 调整选择模式
		INC   DX            ; Port B 的地址
		DEC   BX            ; 计数器-1
	.UNTIL BX == 0
	
	POPF                    ; 恢复 Flag
	RET

DISP ENDP
```

第二个例子使用 82C55 作为步进电机的驱动。步进电机通过线圈通电来吸引 Motor 旋转，按照激励模式，有 full-step, half-step, micro-step 或者 one-phase, two-phase 两种分类方式。

=== "Full Step 粗粒度旋转"
	![[ch11_24.png]]
=== "Half Step 细粒度旋转"
	![[ch11_25.png]]

例如，我们通过 Port 7 来控制步进电机的线圈使能，使用三个线圈来控制 Motor 移动，因此只有低三位是在使用的：

![[ch11_26.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=1</font>

模式 1 开始，外部设备也具有一定状态，需要同步，我们使用 Port C 作为握手信号。

=== "Input Operation"
	![[ch11_27.png]]
	
	- 对于 Group A，外部设备主动发送 $\overline{STB}$ 信号到 PC4 上，这样 82C55 就知道外部设备是否要发送信息；82C55 通过 PC5 发送信号 $IBF$ 来指示外部设备发送的数据是否已经锁存结束，如果锁存结束，则外部设备可以接着去干自己的事情。
	- 数据在 82C55 锁存后，通过 PC3 向 CPU 发送中断请求信号 $INTR$，CPU 收到后发送读信号 $\overline{RD}$，将数据读入。
		- 82C55 判断条件 $\overline{STB}=1, IBF=1$ 来设置 $INTR$，即外部数据已经被锁存住，且被撤掉的情况下，向 CPU 发送请求
		- 上图的中断使能 $INTE$ 其实就是 PC4/2
	
	!!! note "82C55 相当于中转站，CPU 不再直接向外部设备请求数据，而是从 82C55 锁存的数据读取"
		相比于 Mode 0，多了个数据锁存的步骤
	
	!!! tip "注意到 Group A 中用到了 PC3，这是因为 Mode2 下 PC6-PC7 被用于数据输出的控制，上 C 口不够用"
=== "Output Operation"
	![[ch11_28.png]]
	
	- 对于 Group A，CPU 主动向 82C55 发送 $\overline{WR}$ 信号，让 82C55 锁存 CPU 数据总线上的数据；82C55 向外部设备发送 $\overline{OBF}$ 来指示 CPU 有数据要写入
	- 外部设备读入数据后响应 $\overline{ACK}$，82C55 此时向 CPU 发送中断信号 $INTR$，告知 CPU 可以继续写入其它数据
	
	!!! tip "Group B 不会工作在 Mode2，因此它完全可以复用 PC0-PC2 三条信号线"

当然，在输入过程中，我们也可以不等 82C55 给 CPU 发送中断请求，而直接让 CPU 轮询 Port C 的状态。对于 Input，如果查询到 $IBF$ 已经为 1 就可以开始读；对于 Output，如果查询到 $\overline{OBF}$ 为 1 就可以开始写入新的数据（外部设备已经取走锁存的数据）。

下图展示了对于输入设备 Keyboard 的轮询过程，其反复检测直到 Port C 的第五位为 1，才开始读入锁存的 ASCII 数据：

![[ch11_29.png]]

实际上，Mode 1 允许 Group A 和 Group B 分别工作在输入输出两种不同模式下，此时 Command Byte A 中关于 Port C 的控制只影响 Group A 中没有使用的两个位：

=== "Group A Output / Group B Input"
	![[ch11_30.png]]
=== "Group A Input / Group B Output"
	![[ch11_31.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=2</font>

Mode 2 支持 Group A 工作在双工方式下，Port A 的 8 位引脚既可以发送数据，也可以接收数据，且不需要在程序运行中频繁更改模式控制字。

![[ch11_32.png]]

其中 PC4-5 用于输入控制，PC6-7 用于输出控制，PC3 仍然用于中断信号，PC0-2 保留给 Group 用于 Mode 0/1。

有时存在 Input 和 Output 冲突的情况下，实际的时序控制权在外部设备手中：

- **外设控制 $\overline{ACK}$** 来决定什么时候让 82C55 把输出数据“倒”出来。
	- 当 $\overline{ACK}$ 有效时，外设正在读取数据，此时外设不应发送 $\overline{STB}$。
- **外设控制 $\overline{STB}$** 来决定什么时候把自己的输入数据“塞”进去。
	- 当 $\overline{STB}$ 有效时，外设正在发送数据，此时外设绝不能拉低 $\overline{ACK}$。

此时一个可能的时序图如下：

![[ch11_33.png]]

??? question "输入输出共用了 PC3 作为中断线，CPU 该如何判断该中断来自什么事件？"
	通过读取 Port C 来获知当前到底发生了什么。

### 8254

!!! quote
	![[ch11_35.png]]

芯片 8254 是标准的定时器（Timers），只有一个波形信号输出。

8254 内部集成了 3 个独立的 16-bit Counter，每个 Counter 都支持纯二进制计数或 BCD 计数。早期 PC 机中 8254 有如下固定功能：

| **端口地址** | **目标组件**      | **功能描述**                                                  |
| -------- | ------------- | --------------------------------------------------------- |
| **40H**  | **Counter 0** | **系统时钟滴答**：产生约 18.2 Hz 的信号，每秒触发约 18.2 次中断（IRQ0），用于维护系统时间。 |
| **41H**  | **Counter 1** | **DRAM 刷新请求**：设定为 15 $\mu$s，周期性通知 DMA 控制器刷新动态内存，防止数据丢失。   |
| **42H**  | **Counter 2** | **扬声器控制**：连接到 PC 扬声器，通过改变频率来产生不同音调的蜂鸣声。                   |
| **43H**  | **控制寄存器**     | 用于设定上述三个计数器的工作模式和读写格式。                                    |

![[ch11_34.png]]

每个计数器都有关键的三条引脚：

1. **CLK (输入)**：时钟源。每来一个脉冲，计数器减 1。
2. **GATE (输入)**：门控信号。用于控制计数的开始、暂停或重置（类似于秒表的开始键）。门控信号为 0 代表停止计数；门控信号上升沿代表计数开始
3. **OUT (输出)**：结果信号。当计数减到 0（或达到特定条件）时，OUT 引脚会改变电平，触发中断或驱动外设。

单个计数器的内部结构如下图所示：

![[ch11_36.png]]

!!! note "上图除了左上角标绿的控制寄存器，其它都是三个计数器独有的资源"

- 每个计数器中都有单独的控制逻辑，有单独的状态寄存器以及状态锁存器
	- 这允许我们先批量设控制字，再批量赋初值
- 8254 只能接收 8-bit 数据，因此 Counter 内部计数要使用 16-bit 单元，则需要额外使用两个 8-bit 的 Count-Registers 来进行数据读入以及两个 8-bit 的 Output Latches 来进行数据输出
	- 两个 CR 装载到 CE 中只会发生在时钟信号 CLK 的下降沿
	- CE 自减这一事件也只会发生在始终信号 CLK 的下降沿

我们通过修改 Control Word Register 来对三个计数器进行编程控制，每设置一个 Counter 都需要重新设置控制字。


![[ch11_37.png]]

`Read/Write` 位用来解决“如何用 8 位总线读写 16 位数据”的问题，四种组合不同的功能如下：

| **RW1** | **RW0** | **功能说明**                                    | **动作描述**                                | 用处                                                                              |
| ------- | ------- | ------------------------------------------- | --------------------------------------- | ------------------------------------------------------------------------------- |
| **0**   | **0**   | **Counter Latch** (锁存命令)                    | 将当前计数器的值“锁”在输出缓冲器中，方便 CPU 读取，且不停止计数。    | 计数器运行在高速减法中，直接读取当前计数值，可能出现读完低位准备读高位时，高位已经发生了借位；因此 RW=00 会为当前值保存一个快照到 Latch 中供读取 |
| **0**   | **1**   | **Read/Write Least Significant Byte (LSB)** | 只读/写 16 位计数器的 **低 8 位** ($D_7-D_0$)。    | 适用于只需要很小计数值的应用场景；只操作单字节可以减少一条 `OUT` 指令                                          |
| **1**   | **0**   | **Read/Write Most Significant Byte (MSB)**  | 只读/写 16 位计数器的 **高 8 位** ($D_{15}-D_8$)。 | 适用于精度要求不高的应用场景；只操作单字节可以减少一条 `OUT` 指令                                            |
| **1**   | **1**   | **Read/Write LSB followed by MSB**          | **最常用模式**。先读/写低 8 位，紧接着读/写高 8 位。        | 连续两个 `OUT` 指令，自动拼成 16 位                                                         |

!!! tip "先写控制字，再为计数器赋初值；写初值时要满足控制字中的约束"

锁存命令的具体汇编例子如下：

```asm
MOV   AL, 10000000B  ; Counter 2 锁存 
OUT   43H, AL        ; 设置控制字
IN    AL, 42H        ; 读取 Counter 2 LSB
MOV   AH, AL         ; 暂存到 AH
IN    AL, 42H        ; 读取 Counter 2 MSB
XCHAG AH, AL         ; 恢复 Byte Order
```

!!! tip "具体的读取顺序视初始化顺序而定，如果只初始化了 MSB，那么只能读 1B，且返回 MSB"

`SC=11` 表示该控制字是一个回读命令，其用来批量锁存 Counter 以及其状态寄存器的值，格式如下：

![[ch11_50.png]]

如果一个 Counter 的计数器和状态都被锁存，此时读取该端口时先返回 Latched Status，再返回 1-2 Byte 的 Latch Count。

状态寄存器的各个位如下：

```text
# Status Register

    D7         D6       D5    D4    D3   D2   D1   D0
+--------+------------+-----+-----+----+----+----+-----+
| Output | Null Count | RW1 | RW0 | M2 | M1 | M0 | BCD | 
+--------+------------+-----+-----+----+----+----+-----+
```

- $D_7$ 为接口 `OUT` 的值
- $D_6$ 如果为 1，则该计数器未初始化完全（例如未赋初值）；如果为 0，则说明允许被读取
- $D_5 - D_0$ 为计数器的编程模式

计数器采用*减法计数*，因此如果 Initial Count 赋值为 0，它实际代表的是该计数方式下最大的循环值：

- **Binary:** $2^{16}=65536$
- **BCD:** $10^4 = 10000$
	- 4-bit 对应一个 BCD 码，所以对应十进制总共 $16/4$ 位

!!! info "对于最小初始计数值，Mode 2 和 3 下为 2，其余 Mode 中为 1"

??? warning "写入 Initial Count 的原子性"
	- **随时重写 (Dynamic Reloading)：** 你可以随时向计数器写入新的初始值，这**不会改变**已经设定好的工作模式（Mode），但会改变计数器的当前进度。
	- **防止中断干扰 (Byte Integrity)：** 由于 8254 是 16 位计数器，但数据总线通常是 8 位，所以写入一个 16 位计数值需要分**两次**（先低字节后高字节）。
		- **警告：** 绝对不能在写完第一个字节后、还没写第二个字节时，让程序跳转到另一个也会操作同一个计数器的子程序。否则会导致计数值被“张冠李戴”，造成严重的逻辑错误。

| **模式**                    | **计数特点**            | **OUT 初始状态** | **到达 0 后的行为**      | **典型应用场景**  |
| ------------------------- | ------------------- | ------------ | ------------------ | ----------- |
| **Mode 0**<br>**计数结束中断**  | 软件触发（一次性）           | 低            | **变为高**并保持，随后回绕    | 事件计数、定时中断   |
| **Mode 1**<br>**硬件单脉冲**   | 硬件触发（retriggerable） | 高            | 计数开始时变为低，计满后再变高    | 产生定时脉冲、宽度调制 |
| **Mode 2**<br>**分频器/比率计** | 自动重装（periodic）      | 高            | **产生一个窄负脉冲**后循环    | 系统实时时钟、分频   |
| **Mode 3**<br>**方波发生器**   | 自动重装（periodic）      | 高/低切换        | **翻转电平**，产生 50% 方波 | 音乐音调、串行波特率  |
| **Mode 4**<br>**软件触发选通**  | 软件触发（一次性）           | 高            | **产生一个窄负脉冲**后回绕    | 软件控制的精确定时   |
| **Mode 5**<br>**硬件触发选通**  | 硬件触发（retriggerable） | 高            | **产生一个窄负脉冲**后回绕    | 硬件同步脉冲输出    |

!!! tip "所谓自动重装，就是计数器到 0 后立即把 Initial Count 重新装载开始下一轮循环"
	对于其它 Mode（0, 1, 4, 5），计数器归零后只会回绕（Wrap Around），即变为 `FFFFH` 或者 `9999`，然后继续无目的地运行下去，输出信号 `OUT` 不会再变化  

我们之前虽然说过，门控信号为 0 代表停止计数，门控信号上升沿代表计数开始。但不同模式下对门控信号的响应方式也有所区别：

- **电平敏感 (Level Sensitive)** —— _针对 Mode 0, 2, 3, 4_
	- **逻辑**：GATE 像开关。GATE=1 时准许计数；GATE=0 时暂停计数。
	- **采样**：在 CLK 的**上升沿**检查 GATE 的电平。
- **上升沿敏感 (Rising-edge Sensitive)** —— _针对 Mode 1, 2, 3, 5_
	- **逻辑**：GATE 的一个从 0 到 1 的跳变（上升沿）会**重新启动 (Restart)** 计数。
	- **机制**：门控信号上升沿会触发内部的一个触发器（Flip-flop），在下一个 CLK 上升沿被采样后复位。
	- **注意**：Mode 2 和 3 既支持电平使能，也支持上升沿重开。

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=0 interrupt at the end of count</font>

- Initial Count 在 $\overline{WR}$ 后的第一个时钟下降沿被装载，并在之后每个时钟下降沿减一
	- 当计数器为 0 时，输出 OUT 立即置 1，并且产生中断
- 当 GATE 信号为 0 时，停止计数
	- 某个时刻时钟和门控信号同时下降时，仍然要对计数器减一（下图 2）
	- 因为对于电平敏感的模式，我们在**时钟上升沿**采样门控信号，来确定下一个时钟下降沿是否暂停计数
- Mode 0 为软件触发，因此软件写入新值时会重新计数（下图 3）

=== "时序图 1"
	![[ch11_38.png]]
=== "时序图 2"
	![[ch11_39.png]]
=== "时序图 3"
	![[ch11_40.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=1 hardware retriggerable one-shot</font>

- 控制字写完后 OUT 就被初始化为 1，在计数开始时下降为 0；当计数器为 0 时，OUT 立即置 1
- 当门控信号 GATE 出现上升沿时，下一个时钟下降沿会加载初值重新开始计数
- 因为是上升沿敏感的模式，因此计数过程中就算 GATE 变为 0，也仍然继续计数

=== "时序图 1"
	![[ch11_41.png]]
=== "时序图 2"
	![[ch11_42.png]]
=== "时序图 3"
	![[ch11_43.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=2 rate generator</font>

- 计数到 1 时即产生一个负脉冲，然后下一个时钟下降沿恢复初值
	- 因此我们说 Mode 2 和 3 最小初值为 2，因为如果设 1 的话输出 OUT 永远为 0
	- 我们称高电平比例为 Duty Cycle，对于 Mode 2 值为 $\frac{N-1}{N}$，如果 $N=1$，则占空比为 $0$
- Mode 2 同时对电平和上升沿敏感

=== "时序图 1"
	![[ch11_44.png]]
=== "时序图 2"
	![[ch11_45.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=3 square wave generator</font>

- Mode 3 和 Mode 2 类似，但是它的占空比为 $\frac{1}{2}$ 或 $\frac{N+1}{2N}$。
- 例如如果 Initial Count 为 6，那么三个周期为高，三个周期为低，duty cycle 等于 $\frac{3}{6}$

![[ch11_46.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=4 software-triggered strobe</font>

- Mode 4,5 与 Mode 0, 1 对应，区别在于它们输出初值为 1，并且计数为 0 时会发出一个负脉冲

![[ch11_47.png]]


<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=4 hardware-triggered strobe</font>

![[ch11_48.png]]

---

**【Example】**
例如，我们想要通过向 8254 输入 8MHz 的时钟信号，在端口 `0700H` 生成 100KHz 的 Square Wave 以及在端口 `0702H` 生成 200KHz 的 Continuous Pulse，我们的接线如下：

![[ch11_49.png]]

分析要求，我们认为输出需要是连续的、能够自动重装的时钟信号，因此我们只能选用 Mode 2 和 3：

- counter 0 uses mode 3 with count 80 (8M/100K).
- counter 1 uses mode 2 with count 40 (8M/200K).

以下是正确设置计数器的汇编代码：

```asm
; A procedure that programs the 8254 timer to function
; as illustrated above

TIME PROC NEAR USES AX DX

	MOV   DX, 706H       ; 控制字端口
	MOV   AL, 00110110B  ; 设置 counter 0 为 Mode 3
	OUT   DX, AL         
	MOV   AL, 01110100B  ; 设置 counter 1 为 Mode 2
	OUT   DX, AL
	
	MOV   DX, 700H       ; counter 0 端口
	MOV   AL, 80         ; 设置 LSB
	OUT   DX, AL
	MOV   AL, 0          ; 设置 MSB
	OUT   DX, AL
	
	MOV   DX, 702H       ; counter 1 端口
	MOV   AL, 40         ; 设置 LSB
	OUT   DX, AL
	MOV   AL, 0          ; 设置 MSB
	OUT   DX, AL
	
	RET

TIME ENDP
```

??? question "如果我们希望一个 100Hz 的方波呢？"
	$\frac{8M}{100}= 80K > 65536$，因此我们不能直接将 8MHz 的时钟信号接入 Counter 2，该而考虑不同 Counter 之间的串联；例如，可以将 Counter 0 的输出接入 Counter 2 的 CLK，并设置 Initial Count 值为 1000（$\frac{100K}{100}$）

### 16550

16550 是一个串行的通信接口。