
# Basic IO Interface

## Hardware Specifications

> chapter 9

Intel 8086 和 8088 硬件都包装有 40-pin dual in-line packages（DIPs），区别在于 8086 的 Data Bus 宽度为 16-bit，8088 的 Data Bus 宽度为 8-bit。

!!! info "因此 8086 能够更有效率地传输 16-bit 数据，接下来我们也都以 8086 为例"

![[ch11_1.png]]

8086 可以运行在以下两种模式，两种模式下不同引脚功能不同，通过 33 pin 口 $MN/\bar{MX}$ 指示，其中低电平表示 Maximum：

- **Minimum Mode:** 最简单、开销最小的模式
	- 所有 Memory 和 I/O 操作的控制信号都由处理器生成
- **Maximum Mode:** 
	- 允许系统使用外部的 coprocessor，例如 8087（floating-point coprocessor）
	- 一些控制信号只能在外部生成，需要外部数据总线控制

此处我们简要介绍一下部分引脚的功能：

- Pin Connections $AD_{15} - AD_0$
	- 当引脚 ALE 为 0 时，表示该总线上为数据信号
	- 当引脚 ALE 为 1 时，表示该总线上为地址信号，包括 Memory Address 和 I/O Port Number
		- 具体是内存还是 I/O 由另一个引脚的值进行判断
- Address Latch Enable $ALE$：只在 Minimum Mode 下有效
- $M/\bar{IO}$：为 0 时表示总线上为 I/O；为 1 时表示总线上为 Memory
	- 在 8088 中正好相反，为 $IO/\bar M$
- Bus High Enable $BHE$：指示数据总线上高字节是否有效
	- 相对有一个引脚 $BLE$，但该信号不需要额外产生，默认等于 $A_0$
- Read Signal $\bar{RD}$：是否允许数据总线从 Memory 或 I/O 设备中读取数据
- Write Line $\bar{WR}$：指示是否正在向 Memory 或 I/O 设备中输出数据
- Interrupt Request $INTR$：如果 INTR 在 IF = 1 时保持高位，8086/8088 将在当前指令完成执行后进入中断确认循环。
- Non-Maskable Interrupt $NMI$：与 INTR 类似，但是不需要检查 IF，即不可屏蔽中断

## Intro to I/O Interface

硬件接口可以根据如下三种依据进行划分：

- Directions of information flow
	- Input Interface
	- Output Interface
- Types of signal
	- Analog Interface
	- Digital Interface
- Types of data transmission
	- Serial Interface
	- Parallel Interface
	- 这里的串行表示按位传输数据，并行表示按大于位（比如字节）传输数据

![[ch11_2.png]]

在设计接口的过程中，我们尝试明确以下问题：

- **<1> 怎么将 I/O 设备连接到 CPU？**
	- 对于输出接口，使用 Latches
	- 对于输入接口，使用 Three State Buffers
- **<2> 怎么为 I/O 设备提供 Address Space？**
	- 有两种 Schemes：Isolated I/O 和 Memory Mapped I/O
- **<3> 怎么执行 I/O Port Decoding？**
	- 这一过程需要涉及信号 Memory Address, BHE, BLE, IORC, IOWC
- **<4> 怎么实现处理器和 I/O 设备的同步？**
	- unconditional transfer, strobing, handshaking, polling, interrupt-driven, channel-based(e.g. DMA)...

**Isolated I/O** 使用 `IN` 和 `OUT` 指令来做数据的传输，这里的 isolated 意指 I/O 地址空间是和内存地址空间隔离的，称为 **port**。

- **Advantage**
	- port 是隔离的，不需要为设备占用 Memory Address
- **Disadvantage**
	- 只能通过 `IN` 和 `OUT` 指令进行数据交换
	- 需要对 I/O Space 额外产生控制信号
	- 需要特定的 I/O Instruction，导致编程更加复杂

而 **Memory-Mapped I/O** 允许任意指令进行数据交换，I/O 设备将共享内存空间：

- **Advantage**
	- I/O 操作速度与访存操作等价
	- 简化了编程难度
- **Disadvantage**
	- 占用了大量 Memory Address，并且可能空间不够寻址所有 I/O 设备
	- 如果一个设备响应时间很慢，它会拖累 CPU 访问内存的时间，导致整体性能下降

!!! note "PC 使用 Isolated I/O，而不使用 Memory-Mapped I/O"

在硬件上，TTL 和 CMOS 是最常见的两种逻辑管，其中 CMOS 由于消耗更少能量、速度更快而得到了更广泛的应用。对于它们的输入和输出的逻辑电平，有如下规定标准：

=== "TTL Logic Levels"
	![[ch11_3.png]]
	
	!!! note "TTL 通常是 5V，但是为了和 CMOS 兼容也有 3.3V 的版本"
=== "CMOS Logic Levels"
	![[ch11_4.png]]
	
	!!! note "CMOS 的 VCC 可以是 5V, 3.3V, 1.8V"

总结得到下表：

![[ch11_5.png]]

上表下方有两个例子，其中左例 TTL 的输出电平不满足 CMOS 的输入电平要求，即 $VOHmin > VIHmin, VOLmax < VILmax$。

对于输入设备，我们只需要保证电平匹配、信号稳定即可得到对应的逻辑信号，通常使用**三态门**作为中介；而输出设备还需要保证电流大小足够驱动输出设备。

实际控制中，我们要通过设置合理的电阻值来获得额定电流，我们以一个 LED 灯为例：

![[ch11_6.png]]

已知该三极管基极和集电极的电流大小比例为 1:100。对于 Logic 1，我们输入的电压幅度在 2.4V - 5V 范围内，因此我们要保证对于 2.4V 的输入也能驱动该 LED 灯，则对基极和集电极的电阻设置计算如上。

更一般的*感性负载*电机设备中存在很多电感，在我们断电瞬间会产生反向电动势。如果不对该反向电动势进行处理，高额电压可能会损坏三极管。为此，我们需要在三极管两端增加稳压管：

![[ch11_7.png]]

对于输出设备，输出的信号还需要进行锁存，因为输出的信号是持续性的。控制信号此时不再接入使能信号，而是接入时钟信号；当我们使用指令 `OUT 38H, AL` 时，时钟信号就会发生一次跳变，将我们输出信号进行锁存保存。

对于打印机等更“智能”的设备，我们还要求 CPU 能够和外部设备进行异步数据传输，常见有如下两种方法：

- **Strobing** 选通，单向控制信号
- **Handshaking** 握手，双向控制信号

<font style="font-weight: 1000;font-size: 20px" color="orange">Strobing</font>

Strobing 分为 source-initiated transfer 和 destination-initiated transfer 两种：

=== "source-initiated transfer"
	![[ch11_8.png]]
	
	- source 先将数据写入 Data Bus，然后设置控制信号 Strobe 为 1
	- destination 读取数据到寄存器中
	- source 设置控制信号 Strobe 为 0
	- source 从 Data Bus 中移除数据
=== "destination-initiated transfer"
	![[ch11_9.png]]
	
	- destination 设置控制信号 Strobe 为 1
	- source 将数据写入 Data Bus
	- destination 捕获到数据并写入寄存器，然后设置控制信号 Strobe 为 0
	- source 从 Data Bus 中移除数据

选通方式好处在于简单，坏处在于难以控制连接时间。

<font style="font-weight: 1000;font-size: 20px" color="orange">Handshaking</font>

现在稍微复杂点的设备都采用双向信号，两条控制线分别用于 Request 和 Reply。

=== "source-initiated transfer"
	![[ch11_10.png]]
	
	- source 先将数据写入 Data Bus，然后设置 request
	- destination 读取数据到寄存器中，然后设置 reply
	- source 从 Data Bus 中移除数据，并且重置 request
	- destination 重置 reply
=== "destination-initiated transfer"
	![[ch11_11.png]]
	
	- destination 设置 request
	- source 将数据写入 Data Bus，然后设置 reply
	- destination 捕获到数据并写入寄存器，然后重置 request
	- source 从 Data Bus 中移除数据，并且重置 reply

如下例子展示了 PC 和一个 Printer 之间的数据交换过程，ASCII 数据被放置在 $D_7- D_0$ 中，向 port `PRINTER` 发送数据就相当于 request；打印机收到数据后设置 port `BUSY` 为 1 就相当于 reply：

![[ch11_12.png]]


## I/O Port Address Decoding

!!! warning "往年没考，今年必考"

![[ch11_13.png]]

!!! note "这里的 `81H` 既决定了端口，又决定了该指令是 I/O 还是 Memory（实际对于 `IN` 和 `OUT` 指令都是 I/O）"

其中最重要的是左侧部分对 I/O Port 地址的译码。CPU 的 I/O 指令可以使用 8-bit 地址，范围为 `00H-FFH`，所以这种指令的地址线只会用到 $A_7 -A_0$。

不过实际上，PC 实际 I/O 端口都是 16-bit 地址（`0-FFFFH`），我们通过寄存器 `DX` 指定端口，理论上会对 $A_{15}- A_0$ 完整解码。

以 8-bit 地址为例，其中高五位用于选择译码器（译码器使能），低三位用于译码输入，相当于一个 3-to-8 Decoder，其结构如本节开始的图中左侧部分所示。

!!! example "根据图识别该设备地址译码的范围"
	只有译码器使能全为 1，才能启用该地址译码器；例如下图要求 $A_3 - A_7$ 为 `11110`（注意非门是一个圈）
	
	![[ch11_16.png]]

??? success "对于 16-bit 的地址，使用硬件 PLD"
	下图是一个可编程硬件，因此 $A_{11}- A_{15}$ 也是作为译码器使能输入进入的
	
	![[ch11_14.png]]

我们的数据总线通常为 16-bit，但往往只有 8-bit 有效。在 16-bit 微处理器（如 80386SX）里：

- 内存是 16-bit data bus → 由 **两个 8-bit memory bank** 组成 (High bank + Low bank)
- **I/O 空间也是一样！** → 由 **两个 8-bit I/O bank** 组成：

|Bank|数据线|地址例子|
|---|---|---|
|**低字节 (Low bank)**|D7–D0|偶数端口 (40h)|
|**高字节 (High bank)**|D15–D8|奇数端口 (41h)|

```asm
OUT  AL, 40H   ; 写低位 bank，BLE = 0，写入  D7-D0
OUT  AL, 41H   ; 写高位 bank，BHE = 0，写入 D15-D8
```

`BHE` 和 `BLE` 是两个写选通信号，其中 `BLE` 直接设置为 $A_0$，对 I/O 设备进行一个 8 位写入必须明确它要写哪一半。而 8-bit I/O Read 不需要这两个信号，CPU 可以直接通过地址最低位 $A_0$ 来选择读取哪个字节：

- **$\overline{BHE}$ (Bus High Enable):** 当该信号为低电平（0）时，表示启用高位数据总线 ($D_{15}-D_8$)。
- **$A_0$ (Address line 0):** 当该信号为低电平（0）时，表示启用低位数据总线 ($D_7-D_0$)。

![[ch11_15.png]]

??? question "为什么 8-bit 写入需要两个信号？"
	因为数据通道和地址通道都是 16-bit 的，即 $AD_{15}- AD_0$，而“写”这一操作具有破坏性，因此不能只靠低位 $A_0$ 的奇偶来判断是高位还是低位。

!!! example
	- 当访问地址 `41H` 时，译码器的输入为 $\overline{BHE}=0, \overline{IOWC}=0, A_0=1$
	- 当访问地址 `40H` 时，译码器的输入为 $\overline{BHE}=1, \overline{IOWC}=0, A_0=0$
	- 但对于 16L8 这种可编程硬件，$O_1 -O_8$ 的输出并不一定是根据 3-to-8 译码器那样直接，只需要知道对于该图如果 $\overline{BHE}$ 置 0 则访问 high bank 即可
	
	![[ch11_17.png]]

??? success "对于 16-bit port（2-byte aligned），一次写入 16-bit 数据，不再需要 $\overline{BHE}$ 和 $A_0$"
	![[ch11_18.png]]


## Programmable Peripheral

本节介绍三个经典的外部可编程器件。

### 82C55

!!! quote
	![[ch11_19.png]]

芯片 82C55 提供了可编程接口：

- 它提供 **24 条可编程 I/O 引脚**，其中 `82` 表示是外部可编程器件，`C` 表示是 CMOS 低功耗版本，`55` 是流水号，通常越大越新
- 分成 **A、B、C 三个端口**，每个端口都是 8-bit，其中 A、B 口用于数据传输，C 口用于控制信号
	- 三个端口资源不平等，其中 Port A 和 Port C 都有 Output Latch/Buffer 以及 Input Buffer，而 Port B 只有 Output/Input Shared Latch/Buffer，因此只有 Group A 可以同时输入输出（运行在 Mode 2 下）
	- 实际处理中将三个端口分为两个 Group 设置：
	- Group A：Port A(`PA7-PA0`) & Half Port C(`PC7-PC4`)
	- Group B：Port B(`PB7-PB0`) & Half Port C(`PC3-PC0`)
- 可以设置为 **不同模式（Mode 0/1/2）**
	- *Mode 0*：Basic I/O Operation（for group A & B）允许设置端口是输入还是输出，但是同时智能做一件事
	- *Mode 1*：Strobe I/O Operation（for group A & B）新增双向选通信号，考虑外部设备状态
	- *Mode 2*：Bidirectional Bus Operation（for group A only）允许同时输入输出
		- 即只有 Group A 允许工作在模式 2 下，Port C 宽度不够让 Group B 也工作在双工下
- 在 PC 里常用来连接 **键盘、并口、扬声器、定时器** 等设备
	- 通过 I/O 端口（如 60H、378H）进行读写
- 需要通过 **A0/A1** 指定访问端口 A/B/C 或控制寄存器
	- 控制寄存器大小为 8-bit，第七位决定了该控制字为 Command Byte A 还是 B，分别用于不同的功能
	- *Command Byte A:* 设置端口 A、B、C 的控制信号
	- *Command Byte B:* 设置端口 C 的具体比特位 
- 只有信号 **CS=0** 才能访问芯片

???+ example "将 82C55 接入 80386SX 微处理器的 Low Bank 的一个例子"
	- 因为只接了 Low Bank，所以每个 Port 相隔 2-Byte，使用 $A_1 A_2$ 接入到 82C55 的选择信号 $A_1 A_0$
	- 接入的 $\overline{CS}$ 信号为 0，才启用 82C55
	- 考试可能会给出一批地址，问你哪些位接入 $\overline{CS}$，哪些位接入 $A_1 A_0$
	
	![[ch11_21.png]]

$A_1 A_0=11$ 地址的 Command Register 既是控制寄存器又是状态寄存器，Bit Position 7 决定了该字节当前工作在 A 模式还是 B 模式：

- **$D_7 = 1$**：模式定义模式（Mode Definition），用于配置 A、B、C 端口的工作模式和输入/输出方向。
	- 3-6 位为 Group A 服务；0-2 位为 Group B 服务
- **$D_7 = 0$**：位置位/复位模式（Bit Set/Reset），专门用于对 Port C 的某一位进行置 1 或清 0 操作。
	- Command Byte B 中 4-6 位为自由项，可以随意设置
	- 在 Mode 1/2 中，Port C 被用来做握手信号，因此只能按位写；在 Mode 0 中允许对 Port C 正字节写

![[ch11_22.png]]

??? abstract "三种模式的交互模式"
	![[ch11_20.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=0</font>

对于只需要数据输出或者只需要数据输入的设备（如投影仪），我们只需要运行在 Mode 0 即可。

我们以点亮 8-digit 七段数码管为例，使用 Port B 作为 8 个数字的使能与刷新信号，使用 Port A 作为每个七段数码管的数据，接线如下：

![[ch11_23.png]]

观察我们可以得知，Port A 和 Port B 此时都运行在 Mode 0，输出模式下，因此我们对 Command Register 进行设置：

```asm
; programming the 82C55 PIA
MOV AL, 10000000B    ; command (A) 此时 Port C 相关可以随意设置
MOV DX, 703H         ; address port 703H
OUT DX, AL           ; send command to port 703H
```

接下来，我们循环扫描 8 个数字，以达成所有数字同时亮着的视觉效果：

```asm
DISP PROC NEAR USES AX BX DX SI

	PUSHF                   ; 在循环移位中会影响 Flag，因此要保存恢复
	MOV   BX, 8             ; 计数器 Counter
	MOV   AH, 7FH           ; 选择模式，7F 表示第七个 LED 被选中
	MOV   SI, OFFSET MEM - 1; Display Data 的地址（偏移）
	MOV   DX, 701H          ; Port B 的地址 

; DISPLAY ALL 8 DIGITS

	.REPEAT
		MOV   AL, AH        ;  
		OUT   DX, AL        ; 发送选择模式给 Port B
		DEC   DX            ; Port A 的地址
		MOV   AL, [BX+SI]   ;
		OUT   DX, AL        ; 发送数据给 Port A
		CALL  DELAY         ; 延迟等待 1ms
		ROR   AH, 1         ; 调整选择模式
		INC   DX            ; Port B 的地址
		DEC   BX            ; 计数器-1
	.UNTIL BX == 0
	
	POPF                    ; 恢复 Flag
	RET

DISP ENDP
```

第二个例子使用 82C55 作为步进电机的驱动。步进电机通过线圈通电来吸引 Motor 旋转，按照激励模式，有 full-step, half-step, micro-step 或者 one-phase, two-phase 两种分类方式。

=== "Full Step 粗粒度旋转"
	![[ch11_24.png]]
=== "Half Step 细粒度旋转"
	![[ch11_25.png]]

例如，我们通过 Port 7 来控制步进电机的线圈使能，使用三个线圈来控制 Motor 移动，因此只有低三位是在使用的：

![[ch11_26.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Mode=1</font>

模式 1 开始，外部设备也具有一定状态，我们使用 Port C 作为握手信号。

外部设备发送 STB 信号到 PC4 上，这样 CPU 就知道外部设备是否要发送信息；CPU 通过 PC5 发送信号 IBF 来指示外部设备发送的数据是否已经锁存结束，如果锁存结束，则外部设备可以接着去干自己的事情。

数据在 82C55 锁存后，通过 PC3 发送中断请求信号 INTR，CPU 收到后发送读信号 RD，将数据读入。

!!! note "82C55 相当于中转站，CPU 不再直接向外部设备请求数据，而是从 82C55 锁存的数据读取"

!!! tip "注意到 Group A 中用到了端口 PC3，这是因为 PC6-PC7 被用于数据输出的控制，所以上 C 口不够用"

### 8254

芯片 8254 是标准的计时器（Timers），