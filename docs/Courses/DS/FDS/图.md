# å›¾

## Graph å›¾


```c
graph = (int **)malloc(N * sizeof(int *));
for(int i = 0; i < N ; i++){
Â  Â  graph[i] = (int *)malloc(N * sizeof(int));
}//äºŒç»´æ•°ç»„åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºå›¾
```

#### Definition
- **G(V,E)**  : Gä»£è¡¨å›¾ï¼ŒVä»£è¡¨finite nonempty set of vertices(vertexçš„å¤æ•°ï¼Œé¡¶ç‚¹)ï¼ŒEä»£è¡¨finite set of edges
- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$
- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$
- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.
- **Complete Graph** : è¾¹æ•°æœ€å¤§çš„graph 
	- å¯¹äºæ— å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX}= C_n^2$ï¼›        
	- å¯¹äºæœ‰å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX} = 2*C_n^2 = P_n^2$
- **adjacent** : ç›¸é‚»çš„
	- ![[adjacent.png]]
- **Subgraph** : $G'\subset G$ if and only if $V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$
- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}$ such that $(v_p, v_{i1}),(v_{i1}, v_{i2}),$...$, (v_{in}, v_q)$ or $<v_p, v_{i1}>,<v_{i1}, v_{i2}>,$...$, <v_{in}, v_q>$ belong to $E(G)$
- **Length of Path** : pathä¸­è¾¹çš„ä¸ªæ•°(æ³¨æ„ï¼Œæ˜¯è¾¹)
- **Simple Path** : è·¯å¾„æ²¡æœ‰é‡å¤çš„ç‚¹(ä¸åŒ…æ‹¬é¦–å°¾)
- **Circle** : é¦–å°¾ç›¸åŒçš„path
- **(Connected) Component of an undirected G** : æœ€å¤§çš„connected subgraph
- **A tree** : a graph that is connected and acyclic è¿é€šæ— ç¯
- **A DAG** : a directed acyclic graph ==æœ‰å‘æ— ç¯å›¾==
- **Strongly Connected** : å¯¹äºæ¯ä¸€å¯¹$v_i\ v_j$ï¼Œéƒ½åˆ†åˆ«å­˜åœ¨ä»$v_i\ to\ v_j\ ä»¥åŠ\ v_j\ to\ v_i$çš„directed path
- **Weakly Connected** : ä¸ä¸Šé¢ç›¸åŒï¼Œä½†æ˜¯æ˜¯æ— æ–¹å‘å›¾ä¸­ï¼ˆç›´æ¥å°†æœ‰æ–¹å‘å›¾çœ‹ä½œæ— æ–¹å‘å›¾ï¼‰
- **Degree(v)** : ä¸vç›¸è¿çš„è¾¹çš„ä¸ªæ•°ï¼›å¦‚æœæ˜¯æœ‰æ–¹å‘å›¾ï¼Œåˆ™ç”¨in-degreeè¡¨ç¤ºæŒ‡å‘vçš„è¾¹çš„ä¸ªæ•°ï¼Œout-degreeè¡¨ç¤ºä»væŒ‡å‡ºçš„è¾¹çš„ä¸ªæ•°ã€‚
	- ä¹Ÿå› æ­¤å¯ä»¥å¾—åˆ°è¾¹çš„æ€»æ•°ä¸ºdegree(v)çš„å’Œçš„ä¸€åŠ(ä¸€æ¡è¾¹ç”±ä¸¤ä¸ªvertexå…±æœ‰)
- **topological order** : æ‹“æ‰‘åºï¼Œa linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.

### AOV network (Active on vertices)

åœ¨Digraphä¸­ï¼Œç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨æœ‰å‘è¾¹$<v_{i}, v_{j}>$è¡¨ç¤ºæ´»åŠ¨ i æ˜¯æ´»åŠ¨ j çš„å¿…é¡»æ¡ä»¶ã€‚è¿™ç§æœ‰å‘å›¾ç§°ä¸ºç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œï¼Œå³ AOV networkã€‚

æ ¹æ®å®šä¹‰ï¼Œä¸€ä¸ªå¯è¡Œçš„AOV networkå¿…é¡»æ˜¯ DAG (directed acyclic graph)ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†æ‹“æ‰‘åºã€‚

### TopSort

ä¼ªä»£ç å¦‚ä¸‹:

```c
void Topsort( Graph G ){Â Â  
	QueueÂ  Q = CreateQueue( NumVertex );
Â Â Â  MakeEmpty( Q );
Â Â Â  intÂ  Counter = 0;
Â Â Â  VertexÂ  V, W;

Â Â Â  for ( each vertex V )
	Â    if ( Indegree[ V ] == 0 )Â Â  
		Â    Enqueue( V, Q );

Â Â Â  while ( !IsEmpty( Q ) ) {
	Â  V = Dequeue( Q );
	Â  TopNum[ V ] = ++ Counter; /* assign next */
	Â  for ( each W adjacent from V )
	Â  Â Â Â  if ( â€“ â€“ Indegree[ W ] == 0 )Â  
		Â  Â Â Â  Enqueue( W, Q );
Â Â Â  }Â  /* end-while */

Â Â Â  if ( Counter != NumVertex )
	Â  Error( â€œGraph has a cycleâ€ );

Â Â Â  DisposeQueue( Q ); /* free memory */
}
```

### åˆ¤æ–­åºåˆ—Seqæ˜¯å¦æ˜¯æ‹“æ‰‘åº

åœ¨å®æˆ˜ä¸­å°½é‡ç”¨æ•°ç»„è¡¨ç¤ºå§ï¼Œç”¨é“¾è¡¨è¿æ¥å†™çš„çƒ‚å®Œäº†ğŸ˜‚

```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYDå‘½åå¤ªæ··ä¹±äº†ï¼Œè®°ä¸ªæ€è·¯å°±è¡Œ

/*
*æ¯æ¬¡å¾ªç¯å°†ä»Seq[i]outçš„edgeå½’é›¶
*ä¿®æ­£ï¼šä¸ç”¨å½’é›¶ï¼Œå› ä¸ºä¹‹åå°±ä¸ä¼šè°ƒç”¨Seq[i]å¯¹åº”çš„Vertexäº†
*å¹¶ä¸”å½’é›¶å‰æ£€æµ‹ä¸€éå®ƒæŒ‡å‘çš„å…ƒç´ æ˜¯å¦åœ¨Seq[i]å‰é¢ï¼Œ
*è‹¥åœ¨è¯´æ˜falseï¼Œæœ€åéƒ½æ²¡falseå°±true
*/
```

```C
//HWä¸­çš„å®ç°
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[MaxVertexNum]; //AdjList[i]ä¸­å­˜ç¬¬iä¸ªvertexçš„out edgeé“¾è¡¨

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;

LGraph G=ReadG();
```


### Network Flow Problems ç½‘ç»œæœ€å¤§æµé—®é¢˜

![[NetworkFlowé—®é¢˜.png]]

ç»™å®šä¸€ä¸ªå¸¦æƒå›¾ï¼Œä»¥åŠå¤´så’Œå°¾tï¼Œæ±‚ä»såˆ°tå…±æœ‰å¤šå°‘flowå¯ä»¥è¿›å…¥

[è§£å†³æ–¹æ³•](#)

$G_fï¼šæµé‡å›¾\ \ G_rï¼šä½™é‡å›¾\ \ ï¼Œåˆå§‹æ—¶G_fä¸ºç©ºï¼ŒG_rå’ŒGç›¸åŒ$

1. é€‰æ‹©è·¯å¾„ï¼šåœ¨å›¾$G_r$ä¸­ä»»æ„é€‰æ‹©ä¸€æ¡æºç‚¹åˆ°ç›®æ ‡ç‚¹çš„è·¯å¾„
2. æ›´æ–°$G_f$ï¼šåœ¨$G_f$ä¸­æ·»åŠ è¯¥è·¯å¾„ï¼Œè·¯å¾„çš„å¤§å°ç”±æœ€å°æµé‡å†³å®š
3. æ›´æ–°$G_r$ï¼šå¦‚æœè·¯å¾„çš„ä¸€éƒ¨åˆ†ä¸º $a->b$ æ•´æ¡è·¯å¾„æœ€å°æµé‡ä¸ºqï¼Œ$a->b$çš„æœ¬èº«æµé‡ä¸ºpï¼Œåˆ™$G_r$ä¸­æ·»åŠ $b->a$ï¼Œæµé‡ä¸ºqï¼Œ$a->b$çš„æµé‡æ›´æ–°ä¸ºp-q(å¦‚æœä¸º0åˆ™åˆ å»è¿™æ¡è·¯å¾„)
4. é‡å¤1ã€2ã€3ç›´åˆ°$G_r$ä¸­æ‰¾ä¸åˆ°è·¯å¾„

#### dfsç®—æ³•å®ç° Depth-First Search

```cpp
int n, m, s, t; // sæ˜¯æºç‚¹ï¼Œtæ˜¯æ±‡ç‚¹
bool vis[MAXN];
int dfs(int p = s, int flow = INF){
    if (p == t)
        return flow; // åˆ°è¾¾ç»ˆç‚¹ï¼Œè¿”å›è¿™æ¡å¢å¹¿è·¯çš„æµé‡
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next){
        int to = edges[eg].to, vol = edges[eg].w, c;
        // è¿”å›çš„æ¡ä»¶æ˜¯æ®‹ä½™å®¹é‡å¤§äº0ã€æœªè®¿é—®è¿‡è¯¥ç‚¹ä¸”æ¥ä¸‹æ¥å¯ä»¥è¾¾åˆ°ç»ˆç‚¹ï¼ˆé€’å½’åœ°å®ç°ï¼‰
        // ä¼ é€’ä¸‹å»çš„æµé‡æ˜¯è¾¹çš„å®¹é‡ä¸å½“å‰æµé‡ä¸­çš„è¾ƒå°å€¼
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1){
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // è¿™æ˜¯é“¾å¼å‰å‘æ˜Ÿå–åå‘è¾¹çš„ä¸€ç§ç®€æ˜“çš„æ–¹æ³•
            // å»ºå›¾æ—¶è¦æŠŠcntç½®ä¸º1ï¼Œä¸”è¦ä¿è¯åå‘è¾¹ç´§æ¥ç€æ­£å‘è¾¹å»ºç«‹
            return c;
        }
    }
    return -1; // æ— æ³•åˆ°è¾¾ç»ˆç‚¹
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
```

#### bfsç®—æ³•å®ç° 

```cpp
int n, m, s, t, last[MAXN], flow[MAXN];
inline int bfs()
{
    memset(last, -1, sizeof(last));
    queue<int> q;
    q.push(s);
    flow[s] = INF;
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        if (p == t) // åˆ°è¾¾æ±‡ç‚¹ï¼Œç»“æŸæœç´¢
            break;
        for (int eg = head[p]; eg; eg = edges[eg].next)
        {
            int to = edges[eg].to, vol = edges[eg].w;
            if (vol > 0 && last[to] == -1) // å¦‚æœæ®‹ä½™å®¹é‡å¤§äº0ä¸”æœªè®¿é—®è¿‡ï¼ˆæ‰€ä»¥lastä¿æŒåœ¨-1ï¼‰
            {
                last[to] = eg;
                flow[to] = min(flow[p], vol);
                q.push(to);
            }
        }
    }
    return last[t] != -1;
}
inline int EK()
{
    int maxflow = 0;
    while (bfs())
    {
        maxflow += flow[t];
        for (int i = t; i != s; i = edges[last[i] ^ 1].to) 
        // ä»æ±‡ç‚¹åŸè·¯è¿”å›æ›´æ–°æ®‹ä½™å®¹é‡
        {
            edges[last[i]].w -= flow[t];
            edges[last[i] ^ 1].w += flow[t];
        }
    }
    return maxflow;
}
```

### Minimum Spanning Tree æœ€å°ç”Ÿæˆæ ‘

[å®šä¹‰](#)
ä¸€ä¸ªè¿é€šå›¾çš„ç”Ÿæˆæ ‘æ˜¯ä¸€ä¸ªæå°çš„è¿é€šå­å›¾ï¼Œå®ƒåŒ…å«å›¾ä¸­æ‰€æœ‰nä¸ªé¡¶ç‚¹ï¼Œä½†åªæœ‰æ„æˆä¸€æ£µæ ‘çš„n-1æ¡è¾¹ã€‚

æ‰€è°“ä¸€ä¸ª**å¸¦æƒå›¾**çš„ ==æœ€å°ç”Ÿæˆæ ‘== ï¼Œå°±æ˜¯å›¾ä¸­**è¾¹çš„æƒå€¼å’Œæœ€å°çš„ç”Ÿæˆæ ‘**ã€‚


[å±æ€§](#)

- ä¸€ä¸ªå›¾å¯ä»¥æœ‰å¤šä¸ªç”Ÿæˆæ ‘( ==ä¹Ÿå¯ä»¥æœ‰å¤šä¸ªæœ€å°ç”Ÿæˆæ ‘== )
- å¯¹äºåŒ…å«nä¸ªé¡¶ç‚¹çš„æ— å‘å®Œå…¨å›¾æœ€å¤šåŒ…å«$n^{n-2}$é¢—ç”Ÿæˆæ ‘ã€‚
- ç”Ÿæˆæ ‘ä¸­ä¸å­˜åœ¨ç¯
- ç§»é™¤ç”Ÿæˆæ ‘çš„ä»»æ„ä¸€æ¡è¾¹éƒ½ä¼šå¯¼è‡´å›¾çš„ä¸è¿é€š
- åœ¨ç”Ÿæˆæ ‘ä¸­ä»»æ„æ·»åŠ ä¸€æ¡è¾¹éƒ½ä¼šæ„æˆç¯

#### Primç®—æ³•

1. ä»»æ„é€‰æ‹©ä¸€ä¸ªç‚¹ï¼ŒåŠ å…¥ç”Ÿæˆæ ‘(å·²ç»ç”Ÿæˆçš„éƒ¨åˆ†)
2. é€‰æ‹©ä¸è¿™ä¸ªç‚¹ç›¸è¿çš„æƒå€¼æœ€å°çš„è¾¹å’Œç‚¹åŠ å…¥åˆ°ç”Ÿæˆæ ‘
3. å¯¹äºå·²ç»ç”Ÿæˆçš„éƒ¨åˆ†ï¼Œå†æ¬¡é‡å¤2
4. å½“æ‰€æœ‰ç‚¹åŠ å…¥åï¼Œåœæ­¢

#### Kruskalç®—æ³•

1. é€‰æ‹©æƒå€¼æœ€å°çš„è¾¹åŠä¸å®ƒç›¸è¿çš„ç‚¹åŠ å…¥ç”Ÿæˆæ ‘
2. ä»åŸå›¾ä¸­åˆ å»è¿™æ¡è¾¹
3. é€‰å–æƒå€¼æœ€å°çš„ä¸”ä¸æ„æˆCircleçš„è¾¹å’Œç‚¹åŠ å…¥ç”Ÿæˆæ ‘( ==ä¸è¦æ±‚å’Œå·²ç»ç”Ÿæˆçš„éƒ¨åˆ†ç›¸è¿== )
4. ä»åŸå›¾ä¸­åˆ å»è¿™æ¡è¾¹
5. é‡å¤3ã€4ç›´åˆ°åŒ…å«æ‰€æœ‰ç‚¹

åœ¨ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘MSTçš„æ—¶å€™ï¼Œå¯ä»¥é‡‡ç”¨ ==å¹¶æŸ¥é›†== çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤ºè¾¹çš„è¿æ¥å…³ç³»ã€‚

!!! note "Primç®—æ³•æ›´é€‚åˆDense Graph"

### DFSçš„å¦ä¸€ä¸ªåº”ç”¨

- ==articulation point== æŒ‡ä¸€ä¸ªç‚¹ï¼Œå¦‚æœæŠŠè¿™ä¸ªç‚¹ä»å›¾é‡Œåˆ å»ï¼Œåˆ™è¿™ä¸ªå›¾è‡³å°‘æœ‰ä¸¤ä¸ªconnected components (äº¦æ—¢ç¦»æ•£æ•°å­¦ä¸­çš„Cut Vertex)
- ==biconnected graph== æŒ‡ä¸å­˜åœ¨articulation pointçš„è¿é€šå›¾
- ä¸€ä¸ª ==biconnected component== æ˜¯maximal biconnected subgraph

!!! example
	![[biconnectedcomponent.png]]

å¯»æ‰¾biconnected componentçš„Tarjanç®—æ³•ä¸ºï¼š

- ç”¨DFSéå†ä¸€éæ ‘ï¼Œå¹¶å½¢æˆæ·±åº¦ä¼˜å…ˆspanning tree
	- ![[dfsæ‰¾biconnectedcomponent.png]]
- åˆ¤æ–­æ˜¯articulation pointçš„æ¡ä»¶æ˜¯ï¼š
	- å¦‚æœæ ‘çš„æ ¹èŠ‚ç‚¹rootæœ‰è‡³å°‘ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ™rootä¸ºarticulation point
	- å¯¹äºéæ ¹èŠ‚ç‚¹uï¼Œå¦‚æœuæœ‰è‡³å°‘ä¸€ä¸ªå­©å­ï¼Œå¹¶ä¸”ä¸èƒ½å‘ä¸‹ç§»åŠ¨ä¸€æ­¥å†é€šè¿‡è·¯çº¿(åŒ…æ‹¬è™šçº¿)èµ°å›uçš„ç¥–å…ˆ(ä¸åŒ…æ‹¬uè‡ªå·±)ï¼Œé‚£ä¹ˆuä¸ºarticulation point
- å†™æˆç¨‹åºè¯­è¨€ï¼Œåˆ™å¯¹äºæ¯ä¸€ä¸ªvertexæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œ`Num`æŒ‡DFSæ—¶è¢«éå†çš„æ¬¡åºï¼Œ`Low`æŒ‡ä»è¿™ä¸ªç‚¹å‘ä¸‹èµ°æ—¶ç»è¿‡çš„æœ€å°çš„`Num`(å¯ä»¥ç»è¿‡è™šçº¿å›å»)ã€‚é‚£ä¹ˆå¦‚æœuä¸æ˜¯rootï¼Œä¸”uå­˜åœ¨ä¸€ä¸ªå­èŠ‚ç‚¹childä½¿å¾—$Low(child)\ge Num(u)$ åˆ™uæ˜¯articulation point
	- å¯¹äºè¿½æº¯è‡³Lowï¼Œå…¶èµ‹å€¼ä¸ºï¼š åˆå§‹Low[x] = Num[x]
	- å¯¹äºä»Â xÂ åˆ°Â yÂ çš„è¾¹ï¼Œå¦‚æœÂ <x, y>Â åœ¨æœç´¢æ ‘ä¸Šï¼Œåˆ™Â low[x] = min(low[x], low[y])
	- å¦‚æœÂ <x, y>Â ä¸åœ¨æœç´¢æ ‘ä¸Š(å³è™šçº¿éƒ¨åˆ†)ï¼Œåˆ™Â low[x] = min(low[x], num[y])

![[ç†åŒ–æ€æƒ³è§£å†³biconnectedcomponenté—®é¢˜.png]]



### æ¬§æ‹‰å›è·¯ä¸æ¬§æ‹‰è·¯å¾„

- æ¬§æ‹‰å›è·¯ï¼ˆEuler circuitï¼‰ä¸ºåŒ…å«æ‰€æœ‰è¾¹çš„ç®€å•ç¯ï¼Œæ¬§æ‹‰è·¯å¾„ï¼ˆEuler pathï¼‰ä¸ºåŒ…å«æ‰€æœ‰è¾¹çš„ç®€å•è·¯å¾„
- æ— å‘å›¾
    - æ— å‘å›¾Â GÂ æœ‰æ¬§æ‹‰å›è·¯å½“ä¸”ä»…å½“Â GÂ æ˜¯è¿é€šçš„ä¸”æ¯ä¸ªé¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°
    - æ— å‘å›¾Â GÂ æœ‰æ¬§æ‹‰è·¯å¾„å½“ä¸”ä»…å½“Â GÂ æ˜¯è¿é€šçš„ä¸”æœ‰ä¸”ä»…æœ‰ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦æ•°æ˜¯å¥‡æ•°
- æœ‰å‘å›¾
    - æœ‰å‘å›¾Â GÂ æœ‰æ¬§æ‹‰å›è·¯å½“ä¸”ä»…å½“Â GÂ æ˜¯å¼±è¿é€šçš„ä¸”æ¯ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ç­‰äºå…¥åº¦
    - æœ‰å‘å›¾Â GÂ æœ‰æ¬§æ‹‰è·¯å¾„å½“ä¸”ä»…å½“Â GÂ æ˜¯å¼±è¿é€šçš„ä¸”æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦æ¯”å…¥åº¦å¤§Â 1ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªé¡¶ç‚¹çš„å…¥åº¦æ¯”å‡ºåº¦å¤§Â 1ï¼Œå…¶ä½™é¡¶ç‚¹çš„å‡ºåº¦ç­‰äºå…¥åº¦
- dfsÂ å³å¯

```c
void dfs(int x) {
    for (int y = 1; y <= maxn; ++y) {
        if (G[x][y]) {
            G[x][y] = 0;
            G[y][x] = 0;
            dfs(y);
        }
    }
    ans[++ansi] = x;
    return;
}
for (int i = 1; i <= maxn; ++i) {
    if (deg[i] % 2) {
        cnt++;
        if (!root) root = i;
    }
}
if (!root) {
    for (int i = 1; i <= maxn; ++i) {
        if (deg[i]) {
            root = i; 
            break;
        }
    }
}
if(cnt==2 || cnt == 0){
	dfs(root);
}else{
	printf("No Solution\n");
	return 0;
}
```


### æ±‚å¼ºè¿é€šåˆ†é‡çš„Tarjanç®—æ³•

[å¼ºè¿é€šåˆ†é‡ - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/scc/)

åœ¨ Tarjan ç®—æ³•ä¸­ä¸ºæ¯ä¸ªç»“ç‚¹Â uÂ ç»´æŠ¤äº†ä»¥ä¸‹å‡ ä¸ªå˜é‡ï¼š

1. dfn\[u\]ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢éå†æ—¶ç»“ç‚¹ u è¢«æœç´¢çš„æ¬¡åºã€‚
2. low\[u\]ï¼šåœ¨ uÂ çš„å­æ ‘ä¸­èƒ½å¤Ÿå›æº¯åˆ°çš„æœ€æ—©çš„å·²ç»åœ¨æ ˆä¸­çš„ç»“ç‚¹ã€‚è®¾ä»¥Â uÂ ä¸ºæ ¹çš„å­æ ‘ä¸ºÂ Subtree\[u\] ã€‚low\[u\]Â å®šä¹‰ä¸ºä»¥ä¸‹ç»“ç‚¹çš„Â dfnÂ çš„æœ€å°å€¼ï¼šSubtree\[u\]Â ä¸­çš„ç»“ç‚¹ï¼›ä»Â Subtree\[u\]Â é€šè¿‡ä¸€æ¡ä¸åœ¨æœç´¢æ ‘ä¸Šçš„è¾¹èƒ½åˆ°è¾¾çš„ç»“ç‚¹ã€‚

ä¸€ä¸ªç»“ç‚¹çš„å­æ ‘å†…ç»“ç‚¹çš„ dfn éƒ½å¤§äºè¯¥ç»“ç‚¹çš„ dfnã€‚

ä»æ ¹å¼€å§‹çš„ä¸€æ¡è·¯å¾„ä¸Šçš„ dfn ä¸¥æ ¼é€’å¢ï¼Œlow ä¸¥æ ¼éé™ã€‚

æŒ‰ç…§æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•æœç´¢çš„æ¬¡åºå¯¹å›¾ä¸­æ‰€æœ‰çš„ç»“ç‚¹è¿›è¡Œæœç´¢ï¼Œç»´æŠ¤æ¯ä¸ªç»“ç‚¹çš„Â `dfn`Â ä¸Â `low`Â å˜é‡ï¼Œä¸”è®©æœç´¢åˆ°çš„ç»“ç‚¹å…¥æ ˆã€‚æ¯å½“æ‰¾åˆ°ä¸€ä¸ªå¼ºè¿é€šå…ƒç´ ï¼Œå°±æŒ‰ç…§è¯¥å…ƒç´ åŒ…å«ç»“ç‚¹æ•°ç›®è®©æ ˆä¸­å…ƒç´ å‡ºæ ˆã€‚åœ¨æœç´¢è¿‡ç¨‹ä¸­ï¼Œå¯¹äºç»“ç‚¹Â uÂ å’Œä¸å…¶ç›¸é‚»çš„ç»“ç‚¹Â vï¼ˆvÂ ä¸æ˜¯Â uÂ çš„çˆ¶èŠ‚ç‚¹ï¼‰è€ƒè™‘ 3 ç§æƒ…å†µï¼š

1. v æœªè¢«è®¿é—®ï¼šç»§ç»­å¯¹Â vÂ è¿›è¡Œæ·±åº¦æœç´¢ã€‚åœ¨å›æº¯è¿‡ç¨‹ä¸­ï¼Œç”¨Â low[v]Â æ›´æ–°Â low[u] ã€‚å› ä¸ºå­˜åœ¨ä»Â uÂ åˆ°Â vÂ çš„ç›´æ¥è·¯å¾„ï¼Œæ‰€ä»¥Â vÂ èƒ½å¤Ÿå›æº¯åˆ°çš„å·²ç»åœ¨æ ˆä¸­çš„ç»“ç‚¹ï¼ŒuÂ ä¹Ÿä¸€å®šèƒ½å¤Ÿå›æº¯åˆ°ã€‚
2. vÂ è¢«è®¿é—®è¿‡ï¼Œå·²ç»åœ¨æ ˆä¸­ï¼šæ ¹æ® low å€¼çš„å®šä¹‰ï¼Œç”¨Â dfn[v]Â æ›´æ–°Â low[u] ã€‚
3. vÂ è¢«è®¿é—®è¿‡ï¼Œå·²ä¸åœ¨æ ˆä¸­ï¼šè¯´æ˜Â vÂ å·²æœç´¢å®Œæ¯•ï¼Œå…¶æ‰€åœ¨è¿é€šåˆ†é‡å·²è¢«å¤„ç†ï¼Œæ‰€ä»¥ä¸ç”¨å¯¹å…¶åšæ“ä½œã€‚

å°†ä¸Šè¿°ç®—æ³•å†™æˆä¼ªä»£ç ï¼š
```c
TARJAN_SEARCH(int u)
	vis[u]=true 
	low[u]=dfn[u]=++dfncnt 
	push u to the stack 
	for each (u,v) then do 
		if v has not been searched then 
			TARJAN_SEARCH(v) // æœç´¢ 
			low[u]=min(low[u],low[v]) // å›æº¯ 
		else if v has been in the stack then 
			low[u]=min(low[u],dfn[v])
```

C++ä»£ç å®ç°:

```c++
int dfn[N], low[N], dfncnt, s[N], in_stack[N], tp; 
int scc[N], sc; // ç»“ç‚¹ i æ‰€åœ¨ SCC çš„ç¼–å· 
int sz[N]; // å¼ºè¿é€š i çš„å¤§å° 
void tarjan(int u) { 
	low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = 1; 
	for (int i = h[u]; i; i = e[i].nex) { 
		const int &v = e[i].t; 
		if (!dfn[v]) { 
			tarjan(v); 
			low[u] = min(low[u], low[v]); 
		} else if (in_stack[v]) { 
			low[u] = min(low[u], dfn[v]); 
		} 
	} if (dfn[u] == low[u]) { 
		++sc; 
		while (s[tp] != u) { 
			scc[s[tp]] = sc; 
			sz[sc]++; 
			in_stack[s[tp]] = 0; 
			--tp; 
		} scc[s[tp]] = sc; 
		sz[sc]++; 
		in_stack[s[tp]] = 0; --tp; 
	} 
}
```

æ—¶é—´å¤æ‚åº¦ä¸º $O(m+n)$

