
# 网络层

## Concept

### 异构网络互连

网络互连指将两个以上的计算机网络通过一定的方法，用中继系统相互连接起来，以构成更大的网络系统。根据所在层次，中继系统可分为以下四种：


|       | 中继设备    |
| ----- | ------- |
| 物理层   | 转发器、集线器 |
| 数据链路层 | 网桥（交换机） |
| 网络层   | 路由器     |
| 网络层以上 | 网关      |

对于物理层和数据链路层的中继，从网络层的角度来看只是把一个网络扩大了，他们仍然是同一个网络，因此一般不称为网络互连。我们一般称网络互连为通过路由器进行网络连接和路由选择。

**路由选择**和**分组转发**是路由器的主要功能：

- **路由选择** 根据路由协议构造路由表，同时经常或定期地与相邻路由器交换信息，获取网络最新拓扑，动态更新维护路由表，以决定分组到达目的地节点的最优路径
- **分组转发** 根据转发表将分组从合适的端口转发出去

!!! note "路由表是根据路由选择算法得到的，而转发表是根据路由表得出的；讨论路由选择时，往往不区分二者"

### 网络层服务

网络层服务可分为**面向连接的虚电路**服务和**无连接的数据报**服务。

<font style="font-weight: 1000;font-size: 20px" color="orange">虚电路</font>

当两台计算机通信时，先建立一条在网络层上逻辑的虚电路。连接一旦建立，就固定了虚电路对应的物理路径。

!!! note "与电路交换类似，虚电路的通信过程也分为 虚电路建立、数据传输、虚电路释放 三个阶段"

每条虚电路具有一个 VCID，通信双方仅在连接建立时使用完整的目的地址作为分组首部，之后每个分组的首部只需要携带这条虚电路的 VCID 即可。虚电路上每一个节点都维护一个虚电路表，表中每项记录一个打开的虚电路信息，包括在接受链路和发送链路上的 VCID、前一节点和后一节点的标识等，它是在虚电路建立过程中确定的。

<font style="font-weight: 1000;font-size: 20px" color="orange">数据报</font>

网络在发送分组前无需先建立连接，网络不提供端到端的可靠传输服务。

## IPv4

### 分组格式

Internet Protocol 定义了数据传送的基本单元——IP 分组及其确切的数据格式。IP 分组的首部分为前半 20B 固定大小的必要部分以及后半可变大小的可选字段，用来提供错误检测及安全等机制：

![[cn_topic3_1.png]]

- **版本:** 共 4 bit，在 IPv4 数据报中为 4
- **首部长度:** 共 4 bit，以 4B 为单位
	- 最大可表示首部长度为 60B，即该字段值为 15
	- 最常用首部长度为 20B，即该字段值为 5
	- IP 首部前两个字节通常为 0x45
- **总长度:** 共 16 bit，指首部和数据长度之和，以 B 为单位
	- 最大可表示数据报长度为 $2^{16}-1=65535B$
	- 但是数据链路层中最大传送单元（MTU）大小为 1500B 或更小，因此 IP 数据报封装成帧时总长度不能超过该值
- **标识:** 共 16 bit，计数器，每产生一个数据报就加一
	- 一个数据报封装成帧被分片时，他们的标识号是相同的，用来正确重装成原来的数据报
- **标志:** 共 3 bit，目前只有两位有意义
	- 最低位 MF = 1 表示后面还有分片；MF = 0 表示是最后一个分片
	- 中间位 DF = 1 时表示不允许分片；DF = 0 表示允许分片
- **片偏移:** 共 13 bit，表示数据报分片后该片在原数据报中的相对偏移，以 8B 为单位
	- 这也意味着，除了最后一个分片，所有分片的数据部分长度都是 8B 的整数倍
- **生存时间 TTL:** 共 8 bit，数据报在网络中可通过的路由器数量最大值
	- 路由器在转发数据报之前，会对 TTL 进行减一
	- 如果 TTL 减为 0，则丢弃
- **协议:** 共 8 bit，TCP 为 6；UDP 为 17
- **首部检验和:** 共 16 bit，只检验首部
	- 经过路由器时数据报首部会改变，因此每次都要重新计算首部检验和
- **源地址、目的地址:** 共 32 bit，标识发送方和接收方的 IP 地址

### 数据报分片

IP 数据报转发路径上的各段链路可能使用不同的链路层协议，因此有不同的 MTU。例如，以太网的 MTU 为 1500B，而许多广域网的 MTU 不超过 576B。当 IP 数据报总长度大于 MTU 时，就需要将 IP 数据报中的数据分装在多个较小的 IP 数据报中，即**分片**。

例如，一个 4000B 的 IP 数据报（20B 首部，3980B 数据）需要转发到一条 MTU 为 1500B 的链路上。那么经计算，原始数据报中 3980B 数据被分为三片，每片数据部分依次为 1480B、1480B、1020B，它们的标识号均与原始数据报相同：

![[cn_topic3_2.png]]

### IPv4 地址

IP 地址是网络上每台主机或路由器的每一个接口都会被分配的一个全球唯一 32 位标识符，它由**网络号和主机号**组成，其中网络号标志该主机所连接到的网络，主机号标志该主机。

早期互连网使用分类的 IP 地址：

![[cn_topic3_3.png]]

??? question "判断以下地址类型"
	- `10.2.1.1` A 类
	- `128.63.2.100` B 类
	- `201.222.5.64` C 类
	- `256.241.201.10` 不存在，超出范围


| 网络类别 | 第一个可用网络号 | 最后一个可用网络号   | 最大可用网络数  | 每个网络中最大主机数 |
| ---- | -------- | ----------- | -------- | ---------- |
| A    | 1        | 126         | $2^7-2$  | $2^{24}-2$ |
| B    | 128.0    | 191.255     | $2^{14}$ | $2^{16}-2$ |
| C    | 192.0.0  | 223.255.255 | $2^{21}$ | $2^8-2$    |

!!! note "对于 A 类网络，网络号 0 和 127 被特殊地址占用，所以最大可用网络为 $2^7-2$"

在各类 IP 地址中，有些 IP 地址具有特殊用途，不用做主机的 IP 地址：

| 地址              | 用途                         |
| --------------- | -------------------------- |
| 全 0 网络地址        | 只在系统启动时有效，用于启动时临时通信，又叫主机地址 |
| 127.x.x.x       | 指本地节点，用于测试网卡及 TCP/IP 软件    |
| 全 0 主机地址        | 指网络本身                      |
| 全 1 主机地址        | 指本网络的广播地址，也称*直接广播地址*       |
| 0.0.0.0         | 指任意地址                      |
| 255.255.255.255 | 用于本地广播，也称*受限广播地址*          |

### 子网划分

网络号：主机号这种两级 IP 地址的缺点在于不够灵活，有时会导致 IP 地址空间利用率太低。

1985 年以后，IP 地址中新增字段**子网号**，使得两级 IP 地址变为三级 IP 地址。**子网划分 subnetting** 在网络内部将一个网络块进行划分以供多个内部网络使用，对外仍是一个网络。

我们用**子网掩码**来指明分类 IP 地址的主机号部分被借用了多少位作为子网号。子网掩码为 $1^* 0^*$ 组成，主机或路由器只需将 IP 地址与对应子网掩码逐位与运算即可得到相应子网的网络地址。

![[cn_topic3_4.png]]

**无分类编址 Classless Inter-Domain Routing** 在变长子网掩码的基础上，进一步消除了传统 A、B、C 类地址的概念。它使用长度可任意选取的*网络前缀*来代替网络号，因此分配更灵活有效。

CIDR 通常使用斜线记法，例如对于地址 `128.14.32.5/20`，它的掩码是 20 个连续的 1 和后续 12 个连续的 0，通过逐位与即可得到该地址的网络前缀：

![[cn_topic3_5.png]]

### 分组转发

路由器转发表中一定包含*目的网络地址*和*下一跳地址*两个字段，IP 数据报可以通过多次间接交付到达目的主机所在网络的路由器，然后对主机进行直接交付。

如果采用 CIDR 编址，一个分组可能在转发表中找到多个匹配的前缀，此时应该按照**最长前缀匹配 Longest Prefix Match** 原则选择最具体的路由。

> 例如：目标地址是 `192.168.1.25` 路由表中有：
> 
> - `192.168.1.0/24` → eth0
> - `192.168.0.0/16` → eth1
> 
> 系统会选择更“具体”的 `/24` 路由。

此外，路由表中还可以增加两种特殊的路由：

- **<1> 特定主机路由** 对特定目的主机的 IP 地址指定一个路由，以方便管理员控制与测试网络
	- 若特定主机 IP 为 a.b.c.d，则转发表中对应项*目的网络地址*为 a.b.c.d/32，其中 /32 表示的子网掩码没有意义
- **<2> 默认路由** 用特殊前缀 0.0.0.0/0 表示默认路由，所有不在转发表中的目的网络均走默认路由
	- 默认路由通常用于路由器到互联网的路由

### 地址解析

在实际网络链路传送数据帧时，最终必须使用 MAC 地址，所以需要一种方法完成 IP 地址到 MAC 地址的映射，即 **Address Resolution Protocol**。

每台主机都有一个 ARP 缓存，用于存放本局域网上各主机和路由器的 IP 地址到 MAC 地址的映射表，称 ARP 表。

!!! note "ARP 中每个表项都有一定生存时间，超时则会被删除"

当主机 A 要向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 表中查找有无主机 B 的 IP 地址。

- 如果有，就在 ARP 表中查出其对应的硬件地址，再把其硬件地址写入到 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。
- 如果没有，则在本局域网上广播发送一个 ARP 请求分组，广播使用的目的 MAC 地址为 FF-FF-FF-FF-FF-FF。主机 B 在 ARP 分组中见到自己的 IP 地址就向 A 发送ARP响应分组（单播）。主机 A 收到主机 B 的ARP响应分组后，就在其 ARP 缓存表中写入主机 B 的 IP 地址到硬件地址的映射。

ARP 协议解析是自动进行的，用户并不知道地址解析的过程。

### DHCP

**Dynamic Host Configuration Protocol** 用于给主机动态分配 IP 地址，它提供了即插即用的联网机制，允许一台计算机加入新的网络自动获取 IP 地址。

!!! quote "DHCP 是基于 UDP 的应用层协议"

主机向 DHCP 服务器广播*发现报文*，本地网络上的所有主机虽然都能收到该广播报文，但是只有 DHCP 服务器才能回答。DHCP 服务器现在数据库中查找该计算机的配置信息，如果找不到，则从服务器的 IP 地址池中获取一个地址分配给该主机，并回复*提供报文*。

完整的交换过程如下：

![[cn_topic3_6.png]]

因为启动时客户机并不知道服务器的 IP 地址，所以不能建立 TCP 连接，因此采用 UDP 广播的方式。

### ICMP



## 路由算法和路由协议

### 路由算法

路由算法是路由选择协议的核心，决定了路由表的表项是如何获得的。给定一组路由器及连接路由器的链路，路由算法要找到一条从源路由器到目的路由器的最佳路径。

!!! note "这里的“最佳”指具有最低的开销"

根据能否随网络的通信量或拓扑自适应地调整变化，路由算法被划分为如下两大类：

- **<1> 静态路由算法** 指由网络管理员手工配置每一条路由
	- 简单、开销较小，但不能及时适应网络状态变化
	- 适用于简单的小型网络
- **<2> 动态路由算法** 根据网络流量负载和拓扑结构的变化来动态调整自身的路由表
	- 常用的动态路由算法分为**距离-向量路由算法**和**链路状态路由算法**

<font style="font-weight: 1000;font-size: 20px" color="orange">Distance Vector Routing</font>

所有最短路径算法都依赖于一个性质：两点之间的最短路径也包含了其它顶点之间的最短路径。**距离-向量路由算法**使用 Bellman-Ford 算法作为基础，对网络上每个节点 $x$ 维护以下路由信息：

- <1> 从 $x$ 到每个直接相连邻居 $v$ 的链路费用 $c(x,v)$
- <2> 节点 $x$ 的距离向量，即 $x$ 到网络中其它节点的开销
	- 这是一组距离，因此称为*距离向量*
- <3> $x$ 的每个邻居的距离向量

!!! info "Bellman-Ford 算法用于计算单源最短路径，$d_x(y)$ 表示点 $x$ 到 $y$ 的最短距离"

在距离-向量算法中，每个节点定期向它的每个邻居发送自己的距离向量副本。当节点 $x$ 从邻居 $v$ 收到了一个新距离向量时，它会使用 Bellman-Ford 公式 $d_x(y) = \min \{c(x,y) + d_v(y)\}$ 来更新自己的距离向量。如果 $x$ 的距离向量因此而改变，则它接下来继续向它的每个邻居发送更新后的距离向量。

显然，用于更新路由的更新报文大小与网络中节点数量成正比，因此大型网络将导致很大的更新报文，并且 Bellman-Ford 算法时间复杂度可达 $O(N\times E)\approx O(N^3)$。

!!! quote "距离向量算法的特点是迭代、分布式"
	- 每次本地迭代由下列引起：本地链路费用改变、邻居更新报文
	- 各节点依次计算，相互依赖

<font style="font-weight: 1000;font-size: 20px" color="orange">Link State Routing</font>

我们将本路由器都和哪些路由器相邻（网络拓扑）以及相应链路的代价称为**链路状态**。链路状态算法会维护一个全网范围内一致的拓扑结构图，每个节点会执行下列两项任务：

- 主动测试所有相邻节点的状态
- 定期将链路状态传播给所有其它节点
	- 因此每个节点都直到全网共有多少个节点、那些节点是相连的、其代价是多少
	- 每个节点都可根据全局链路状态通过 Dijkstra 算法计算出到达其它节点的最短路径

在链路状态算法中，虽然每个节点需要存储更多数据（网络拓扑结构图），但是它们只需要通过**广播**的方式告诉其它所有节点它与它直接相邻的链路的代价，报文大小与网络中节点数量无关。


### 路由协议

互联网被划分为许多较小的**自治系统 Autonomous System AS**。自治系统是在单一技术管理下的一组路由器，这些路由器使用一种 AS 内部的路由选择协议和共同的度量。

- **Interior Gateway Protocol, IGP** 是在一个自治系统内部使用的路由选择协议，它与互联网中其它 AS 选用什么路由选择协议无关，包括我们上面所说的两种路由算法
- **External Gateway Protocol, EGP** 用来传递不同自治系统中的路由选择信息，例如源主机和目的主机不在同一 AS 中，就需要用到 EGP

!!! tip "自治系统之间的路由选择称为域间路由选择，自治系统内部的路由选择称为域内路由选择"


| 协议   | RIP                   | OSPF               | BGP                |
| ---- | --------------------- | ------------------ | ------------------ |
| 类型   | IGP                   | IGP                | EGP                |
| 路由算法 | 距离向量                  | 链路状态               | 路径向量               |
| 传递协议 | UDP                   | IP                 | TCP                |
| 路径选择 | 跳数最少                  | 代价最低               | 较好，非最佳             |
| 交换节点 | 和本节点相邻的路由器            | 网络中所有路由器           | 和本节点相邻的路由器         |
| 交换内容 | 当前本路由器知道的全部信息，即自己的路由表 | 与本路由器相邻的所有路由器的链路状态 | 首次为整个路由表，以后为有变化的部分 |


<font style="font-weight: 1000;font-size: 20px" color="orange">Routing Information Protocol, RIP</font>

路由信息协议是 IGP 中最先得到广泛应用的协议，它是一种分布式的基于距离向量的路由选择协议。

RIP 使用跳数（或距离）来衡量到达目的网络的距离，规定从一路由器到直接连接的网络的条数为 1，每经过一个路由器，跳数加 1。网络中每个路由器都要维护从它自身到其它目的网络的跳数，即*距离向量*，每个路由表项都有三个关键字段：目的网络 $N$，距离 $d$，下一跳路由器地址 $X$。

RIP 允许一条路径中最多只能包含 15 个路由器，因此跳数为 16 表示网络不可达，因此 RIP 只适用于小型互联网。

!!! warning "规定最高跳数是为了防止分组不断在环路上循环的情况"

RIP 中每个路由器都要不断和其它路由器交换信息：

- 1）和谁交换信息：仅和直接相邻的路由器交换信息
- 2）交换什么信息：交换本路由器所知道的全部信息，即自己的路由表
- 3）何时交换信息：按固定的时间间隔（通常为 30s）交换路由信息；当网络拓扑发生变化时，路由器也需即使向相邻路由器通告拓扑变化后的路由信息

路由器刚启动时只知道自己到直接相连的几个网络的距离为 1。每个路由器仅和相邻路由器周期性地交换并更新路由信息，经过若干次交换和更新后，所有的路由器最终都会直到到达本 AS 内任何网络的最短距离和下一条路由器的地址，称为**收敛**。

!!! example "RIP 的更新过程"
	![[cn_topic3_7.png]]

<font style="font-weight: 1000;font-size: 20px" color="orange">Open Shortest Path First, OSPF</font>

OSPF 协议也是 IGP 的一种，是使用*分布式链路状态路由算法*的典型代表，与 RIP 相比具有以下四个主要特点：

- 1）OSPF 使用洪泛法向本 AS 中的所有路由器发送信息，而 RIP 仅向自己相邻的几个路由器发送信息
	- 具体而言，OSPF 中路由器向所有相邻路由器发送信息，而每个相邻路由器又将次信息发往所有的相邻路由器（除了刚刚发来信息的那个路由器），最终所有路由器都收到了这个信息的副本
- 2）发送的信息是与本路由器相邻的所有路由器的链路状态，而 RIP 发送的信息是整个路由表
- 3）只有当链路状态发生变化时才会发送信息，并且收敛更快，而 RIP 不管网络拓扑是否发生变化，也要定期交换路由表信息
- 4）OSPF 是网络层协议，直接用 IP 数据报传送，而 RIP 是应用层协议，它在传输层使用 UDP

因为各路由器之间频繁地交互链路状态信息，所以所有路由器最终都能建立一个链路状态数据库，即全网拓扑结构图。然后，每个路由器利用链路状态数据库中的数据，使用 Dijkstra 算法计算自己到达各目的网络的最优路径，构造出自己的路由表。

!!! note "虽然使用 Dijkstra 算法能够得到完整的最优路径，但是路由表中仍只存储下一跳的地址"

??? quote "除此之外，OSPF 还有以下特点"
	- OSPF 允许对每条路由设置不同的代价，对于不同类型的业务可计算出不同的路由
	- 若到同一个目的网络有多条相同代价的路径，则可将通信量分配给这几个路径
	- OSPF 分组具有鉴别功能，从而保证仅在可信赖的路由器之间交换链路状态信息
	- OSPF 支持可变长度的子网划分和无分类编址 CIDR
	- 每个链路状态都有一个 32 位的序号，序号越大，状态越新

<font style="font-weight: 1000;font-size: 20px" color="orange">Border Gateway Protocol, BGP</font>

边界网关协议是不同 AS 的路由器之间交换路由信息的协议，属于 EGP。

BGP 是基于 TCP 的*应用层协议*，采用了路径向量路由选择，目的是力求寻找一条能够到达目的网络且比较好的路由（并不一定是最佳路由）。

BGP 不仅运行在 AS 之间，还运行在 AS 内部，根据 BGP 路由信息交换的对等双方类型，我们有以下两种会话分类：

- **external BGP, eBGP:** 跨越两个 AS 的 BGP 会话称为 eBGP，用于从相邻 AS 获得网络可达信息
- **internal BGP, iBGP:** 同一 AS 内部两个路由器间的 BGP 会话称为 iBGP，用于将网络可达信息传播给 AS 内的路由器

BGP 中最重要的两个属性为 *AS-PATH* 和 *NEXT-HOP*，路由器通过 BGP 报文学习到某一终点所需经过的路径：

![[cn_topic3_8.png]]

例如，对于如上例子，边际路由器 R1a 从 R2a 收到报文 `C, AS2, AS3, R2a`，它的含义是“从 R2a 出发能够到达 AS2->AS3 中的网络 C”，即 $R1a\rightarrow R2a \rightarrow ... \rightarrow C$。

而对于网络 $A$，它会收到 iBGP 报文 `C, AS2, AS3, R1a`，表示它要到达网络 $C$ 需要将分组转发到同一 AS 内部的路由器 R1a 上。此时需要根据内部网关协议找到从网络 $A$ 到达 R1a 的最佳路由的下一跳并转发，而并不一定是直接转发到 R1a。

当 BGP 刚刚运行时，BGP 的邻站要交换整个的 BGP 路由表；以后只需要在发生变化时更新有变化的部分。

BGP 报文通常通过半永久端口 179 进行交换，包括以下四类：

- **Open 报文:** 用于与相邻 BGP 对等方建立关系，使通信初始化
	- 两个路由器建立 TCP 连接后必须发送 Open 报文，以相互识别对方，并协商一些参数
- **Update 报文:** 用于通知某一路由的信息，以及列出要撤销的多条路由
	- 撤销路由可以一次撤销多条，但新增路由只能一次增加一条
- **Keepalive 报文:** 用于周期性地证实邻站的连通性
	- 除此之外，收到 Open 报文的路由器要发回 Keepalive 报文表示接受建立 BGP 连接
- **Notification 报文:** 用来发送检测到的差错

## 拥塞控制算法

