# ä¸€äº›æ•°æ®ç»“æ„çš„å®ç°

## ADT : The Abbreviation of Abstract Data Type

```
pandoc .\Project.md -s --highlight-style tango -o pr.pdf
```

## Sequential Linear List é¡ºåºå­˜å‚¨çº¿æ€§è¡¨

ç”¨æ•°ç»„è¡¨ç¤ºçº¿æ€§è¡¨çš„ä¼˜ç‚¹æ˜¯ä¾¿äºéšæœºå­˜å– **(æ‰€è°“éšæœºå­˜å–ï¼Œå°±æ˜¯é€šè¿‡é¦–åœ°å€å’Œå…ƒç´ çš„ä½åºå·å€¼å¯ä»¥åœ¨O(1)çš„æ—¶é—´å†…æ‰¾åˆ°æŒ‡å®šçš„å…ƒç´ )**

é¡ºåºè¡¨çš„ä¼˜ç‚¹æ˜¯**å­˜å‚¨å¯†åº¦**(å­˜å‚¨åˆ©ç”¨ç‡)é«˜

## Linked List é“¾è¡¨çš„åˆ›å»ºä¸æ·»åŠ èŠ‚ç‚¹

å•å‘é“¾è¡¨é€šå¸¸æœ‰ä¸ªdummy headï¼Œå› æ­¤å¤´æŒ‡é’ˆå­˜æ”¾çš„ä¸æ˜¯å¤´ç»“ç‚¹çš„å†…å®¹

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(PtrToNode)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

## Stack æ ˆ

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

### ä»¥é“¾è¡¨çš„æ–¹å¼å®ç°æ ˆ

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp çš„ä½œç”¨å°±æ˜¯é‡Šæ”¾ç©ºé—´
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

## Queue é˜Ÿåˆ—(é“¾è¡¨å®ç°æ–¹å¼)

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

## Tree æ ‘

ç”±äº$2n_2 + n_1 +1= n_2 +n_1+ n_0$ ï¼Œæ‰€ä»¥$n_2= n_0-1$ï¼Œåº¦ä¸º2çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºå¶ç»“ç‚¹ä¸ªæ•°å‡ä¸€

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree Left;
    Tree Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

### ä»ä¸­åºéå†å’Œååºéå†å¾—åˆ°ä¸€ä¸ªäºŒå‰æ ‘

```c
int main(void){
Â  Â  Tree T;
Â  Â  int inorder[MAXN], postorder[MAXN], N, i;
Â  Â  scanf("%d", &N);
Â  Â  for (i=0; i<N; i++) scanf("%d", &inorder[i]);
Â  Â  for (i=0; i<N; i++) scanf("%d", &postorder[i]);
Â  Â  T = BuildTree(inorder, postorder, N);
}
Tree BuildTree(int inorder[],int postorder[],int N){
Â  Â  Tree root=(Tree)malloc(sizeof(struct TreeNode));
Â  Â  int index;
Â  Â  if(N<=0){
Â  Â  Â  Â  return NULL;
Â  Â  }else if(N==1){
Â  Â  Â  Â  root->Element=postorder[N-1];
Â  Â  Â  Â  root->Left=NULL;
Â  Â  Â  Â  root->Right=NULL;
Â  Â  Â  Â  return root;
Â  Â  }
Â  Â  root->Element=postorder[N-1];
Â  Â  for(int i=0;i<N;i++)
Â  Â  Â  Â  if(inorder[i]==postorder[N-1]){
Â  Â  Â  Â  Â  Â  index=i;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  root->Left=BuildTree(inorder,postorder,index);
Â  Â  root->Right=BuildTree(inorder+index+1,postorder+index,N-index-1);
Â  Â  return root;
}
/*è‹¥æ˜¯æƒ³è¦ä»¥zigzagging orderè¾“å‡ºçš„è¯ï¼Œå»ºç«‹ä¸¤ä¸ªæ ˆï¼Œ
 *ç¬¬ä¸€ä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¾æ¬¡å°†å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹å‹å…¥ç¬¬äºŒä¸ªæ ˆä¸­ï¼›
 *ç¬¬äºŒä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¸€æ¬¡å°†å³èŠ‚ç‚¹å’Œå·¦èŠ‚ç‚¹å‹å…¥ç¬¬ä¸€ä¸ªæ ˆä¸­ï¼Œæ¯ä¸ªæ ˆç©ºäº†ä¹‹åè½®æ¢åˆ°ä¸‹ä¸€ä¸ªæ ˆ
 */
```


### çº¿ç´¢äºŒå‰æ ‘ Threaded

å»ºæ ‘çš„æ—¶å€™ï¼Œæ¯ä¸ªèŠ‚ç‚¹æ˜¯æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼ˆæŒ‡å‘ä¸€å·¦ä¸€å³ï¼‰çš„ï¼ŒNä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯2Nä¸ªæŒ‡é’ˆï¼Œä½†æ˜¯å®é™…ä¸Šä¸æ˜¯Nullçš„åªæœ‰N-1ä¸ªï¼Œå› ä¸ºé™¤äº†æ ¹éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘è¿™ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰N+1ä¸ªæŒ‡é’ˆæ²¡æœ‰ç”¨ï¼Œçº¿ç´¢äºŒå‰æ ‘å°±æ˜¯ä¸ºäº†è®©è¿™N+1ä¸ªèŠ‚ç‚¹æœ‰ç”¨ï¼ŒæŒ‡å‘çš„å°±æ˜¯ä½ çš„æ’åºæ–¹å¼ç»™å‡ºåï¼Œé‚£ä¸ªçº¿æ€§æ’åˆ—çš„â€œå‰é©±â€å’Œâ€œåé©±â€ï¼Œå·¦æŒ‡é’ˆæŒ‡å‘å‰é©±ï¼Œå³æŒ‡é’ˆæŒ‡å‘åé©±ã€‚

å› æ­¤å†™é€‰æ‹©é¢˜çš„æ—¶å€™å¯ä»¥å…ˆå°†éå†ï¼ˆæ— è®ºæ˜¯å‰åºè¿˜æ˜¯ååºè¿˜æ˜¯ä¸­åºï¼‰åˆ—å‡ºæ¥ï¼Œå†å°†è™šçº¿è¿ä¸Šå»ã€‚
![[çº¿ç´¢äºŒå‰æ ‘.png]]

## Priority Queue å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—

```c
typedef struct HeapStruct *PriorityQueue; //è®¾ä¸ºæŒ‡é’ˆå½¢å¼æ–¹ä¾¿ç›´æ¥åœ¨å‡½æ•°ä¸­ä¿®æ”¹å€¼
struct HeapStruct {
    int *Elements;
    int Capacity;
    int Size;
};
// å…¶å®æ›´å¤šä»¥æ•°ç»„çš„æ–¹å¼å®ç° å·¦å­æ ‘ï¼š2*index å³å­æ ‘ 2*index+1 çˆ¶èŠ‚ç‚¹ index/2
// æ³¨æ„ï¼Œæœ‰ä¸ªdummy headï¼Œæ ¹èŠ‚ç‚¹ä»index = 1å¼€å§‹
```


```c
PriorityQueue Initialize(int MaxElements){
	PriorityQueue H=(PriorityQueue)malloc(sizeof(struct HeapStruct));
	if(H==NULL)
		exit(1);
	H->Elements=(int*)malloc((MaxElements+1)*sizeof(int)); //ç•™ä¸€ä¸ªç©ºä½ç»™dummyhead
	if(H->Elements==NULL)
		exit(1);
	H->Capacity=MaxElements;
	H->Size=0;
	return H;
}
```

```c
void Insert(int X,Priority H){
	int i;
	if(isFull(H)){
		return;
	}
	for(i=++H->Size;H->Elements[i/2]>X;i/=2){ //minHeapçš„æƒ…å†µ
		H->Elements[i]=H->Elements[i/2];
	}H->Elements[i]=X;
}
```

### Deleteæ“ä½œ
```c
//è¿›è¡Œdeleteæ“ä½œï¼Œæ€è·¯æ˜¯åˆ é™¤æœ€å°å…ƒç´ ï¼Œå°†é˜Ÿå°¾å…ƒç´ ç§»è‡³rootå¤„ï¼Œå†ä¸‹æ»¤è‡³ç¬¦åˆè¦æ±‚
int DeleteMin(Priority H){
	int i,child;
	int MinElement,LastElement;
	if(isEmpty(H))
		return;
	MinElement=H->Elements[1];
	LastElement=H->Elements[H->Size--];
	for(i=1;i*2<=H->Size;i=child){
		child=i*2;
		if(child!=H->Size && H->Elements[child+1]<H->Elements[child])
			child++;
		if(LastElement>H->Elements[child])
			H->Elements[i]=H->Elements[child];
		else
			break;
	}
	H->Elements[i]=LastElement;
	return MinElement;
}
```

å¦‚æœä½ å·²ç»å®šä¹‰è¿‡äº†PercolateDownçš„å‡½æ•°ï¼Œä½ ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨æ¥å®Œæˆä¸Šè¿°DeleteMinæ“ä½œã€‚

```c
void PercolateDown(int p,PriorityQueue H){ //ä¸‹æ»¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸ºæ ‘çš„é«˜åº¦O(h)
    int min;
    while(2*p<=H->Size && 2*p+1<=H->Size){
        if(H->Elements[2*p]<H->Elements[2*p+1])
            min = 2*p;
        else
            min = 2*p+1;
        if(H->Elements[min]<H->Elements[H->Size+1]){
            H->Elements[p]=H->Elements[min];
            p=min;
        }else
            break;
    }//æ³¨æ„å¾ªç¯ç»“æŸåè¿˜è¦åŠ ä¸ªåˆ¤æ–­å·¦å­æ ‘æ˜¯å¦è¿˜å¯ä»¥downçš„æ“ä½œï¼Œå› ä¸ºCompleteTreeå³å­æ ‘å¯èƒ½ä¸å­˜åœ¨ã€‚
    if(2*p<=H->Size && H->Elements[2*p]<H->Elements[H->Size+1]){ /
        H->Elements[p]=H->Elements[2*p];
        p=p*2;
    }H->Elements[p]=H->Elements[H->Size+1];
}
void PercolateUp(int p,PriorityQueue H){
    int tmp;
    while(p/2>=1 && H->Elements[p/2]>H->Elements[p]){
        tmp=H->Elements[p/2];
        H->Elements[p/2] = H->Elements[p];
        H->Elements[p] = tmp;
        p=p/2;
    }
}

//å…·ä½“è°ƒç”¨å¦‚ä¸‹:
H->Size--;
PercolateDown(1,H);
```

### å»ºå †æ“ä½œ

**å¯¹äºæœªæˆå †çš„Heapï¼Œæˆ‘ä»¬ä¸€èˆ¬ä»$\lfloor \frac{n}{2} \rfloor$å¼€å§‹ä¸‹æ»¤ï¼Œå®Œæˆæ’åºï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦ä¸ºO(n)å“¦ã€‚**

$T=\sum_1^{h+1} 2^{h+1} -1 -2^h= 2^{h+1} -1-(h+1)=O(n)$

### d-heap

æ³¨æ„ï¼Œd-heapæŒ‡ä¸€ä¸ªèŠ‚ç‚¹æœ‰dä¸ªå­©å­ï¼ˆå½“ç„¶è¿˜æ˜¯å®Œå…¨æ ‘å“¦~ï¼‰
```c
child(i,j) = d*(i-1)+2+j    (iæ˜¯çˆ¶äº²ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œjæ˜¯ç¬¬å‡ ä¸ªå„¿å­ï¼ŒèŒƒå›´æ˜¯0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (è¿™æ˜¯d-heapæœ€åä¸€ä¸ªæœ‰å¶å­çš„ç»“ç‚¹ã€‚åœ¨heapé‡Œæ˜¯size()/2)
```

### å †æ’åº

åˆ©ç”¨æœ€å¤§å †æœ€å¤§çš„å…ƒç´ åœ¨æ ¹èŠ‚ç‚¹çš„æ€§è´¨ï¼Œå¯ä»¥å¯¹æ•°ç»„è¿›è¡Œæ’åºã€‚

å…·ä½“å®ç°åŸç†ä¸º:

- å…ˆå°†åˆå§‹çš„R[1,...,n]å»ºç«‹æˆæœ€å¤§å †ï¼Œæ­¤æ—¶æ˜¯æ— åºå †ï¼Œè€Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ ã€‚
- å†å°†å †é¡¶R[1]å’Œæœ€åä¸€ä¸ªå…ƒç´ R[n]äº¤æ¢ï¼Œç”±æ­¤å¾—åˆ°æ–°çš„æ— åºåŒºR[1,...,n-1]ä¸æœ‰åºåŒºR[n]ã€‚
- å°†æ— åºåŒºå†æ¬¡å»ºå †(åªç”¨å¯¹R[1]è¿›è¡Œä¸‹æ»¤æ“ä½œå³å¯)ï¼Œé‡å¤ä¸Šè¿°æ“ä½œã€‚
- ç›´åˆ°æ— åºåŒºåªå‰©ä¸‹æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¯ä»¥å¾—åˆ°é€’å¢åºåˆ—ã€‚
## Disjoint Set å¹¶æŸ¥é›†

ç­‰ä»·å…³ç³»**R**çš„ä¸‰ä¸ªæ€§è´¨:

- **Reflexive** è‡ªåæ€§ï¼š
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** å¯¹ç§°æ€§:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** ä¼ é€’æ€§ï¼š
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

ä¸€èˆ¬å°†rootçš„å€¼è®¾ä¸ºå…¶**æ ‘çš„å¤§å°çš„è´Ÿå€¼**

**å¦‚æœè¦ç»™é•¿åº¦ä¸ºNçš„Union(æ•°ç»„å®ç°)èµ‹åˆå€¼(å³å…¨ä¸º-1)ï¼Œä¸èƒ½é‡‡ç”¨å¦‚ä¸‹å†™æ³•:**
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *å®é™…ä¸Šuni[N+1] = {0};ä¹Ÿæ˜¯ä¸å…è®¸çš„ï¼Œæ•°ç»„é•¿åº¦ä¸ºå˜é‡çš„è¯ä¸èƒ½èµ‹åˆå€¼ï¼›
    *å†µä¸”è¿™é‡Œå†™-1æœ€å¤šä¹Ÿåªèƒ½æŠŠç¬¬ä¸€ä¸ªèµ‹ä¸º-1ï¼ˆå³ä¸º-1,0,0,0,...ï¼‰
    */
    --- --- --- --- ---
    //æ­£ç¡®å†™æ³•å¦‚ä¸‹:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){
    //è¿™é‡Œæ—¶é—´å¤æ‚åº¦ä¸ºO(N) ï¼Œå°†æ•´ä¸ªä»£ç éƒ½æ‹‰è·¨äº†ï¼Œæœ‰ä»€ä¹ˆåŠæ³•å‘¢ï¼Ÿ
        uni[i]=-1;
    }
    --- --- --- --- ---
    //å…¶å®è¿˜çœŸæœ‰æ–¹æ³•
    #include<srting.h>
    int *uni=(int*)malloc(N*sizeof(int));
    memset(uni,-1,sizeof(uni));
    //å¯¹äºæ•´æ•°æ•°ç»„ï¼Œmemsetå‡½æ•°åªèƒ½èµ‹åˆå€¼0æˆ–-1ï¼Œè¯·åŠ¡å¿…æ³¨æ„
```

```c
//ä¸€ç§åŠ¨æ€åˆ†é…çš„æ–¹æ³•
int *uni;
uni=(int*)calloc(N+1,sizeof(int));
```

### ä¼˜åŒ–Findç®—æ³• è·¯å¾„å‹ç¼©

```C
//ä¼˜åŒ–è¿‡çš„findç®—æ³•ï¼Œæ‰¾rootçš„æ—¶å€™é¡ºä¾¿å‡å°‘äº†depth
//é€’å½’ç‰ˆæœ¬
int Find ( int X , DisjSet S ){
	if ( S[ X ] <= 0 )
		return X;
	else 
		return S[ X ] = Find( S[ X ], S );
}
```

```c
//è¿­ä»£ç‰ˆæœ¬
intÂ  Find ( intÂ  X, DisjSetÂ  S ){Â Â  
	intÂ  root,trail,lead;

Â Â Â  for ( root = X; S[ root ] > 0; root = S[ root ] );Â  // find the root
Â Â Â  for ( trail = X; trail != root; trail = lead ) {
Â Â Â Â Â Â  lead = S[ trail ] ;Â Â 
Â Â Â Â Â Â  S[ trail ] = root ;Â Â 
Â Â Â  }Â  //æŠŠè·¯ä¸Šé‡åˆ°çš„èŠ‚ç‚¹å…¨è¿æ¥åˆ°rootä¸Š
Â Â Â  returnÂ  root ;
}
```

### åˆå¹¶ Union

```c
void SetUnion(int n1, int n2, int S){
	int root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
//æŒ‰è¿™ç§æ–¹å¼Unionçš„å¹¶æŸ¥é›†ï¼Œåˆ™ä»»ä½•èŠ‚ç‚¹çš„æ·±åº¦å‡ä¸ä¼šè¶…è¿‡$log_2 N$
```


## Graph å›¾



```c
Â  Â  graph=(int**)malloc(N*sizeof(int*));

Â  Â  for(int i=0;i<N;i++){

Â  Â  Â  Â  graph[i]=(int*)malloc(N*sizeof(int));

Â  Â  }
Â  Â  //äºŒç»´æ•°ç»„åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºå›¾
```

#### Definition
- **G(V,E)**  : Gä»£è¡¨å›¾ï¼ŒVä»£è¡¨finite nonempty set of vertices(vertexçš„å¤æ•°ï¼Œé¡¶ç‚¹)ï¼ŒEä»£è¡¨finite set of edges

- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$

- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$

- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.

- **Complete Graph** : è¾¹æ•°æœ€å¤§çš„graph 
å¯¹äºæ— å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX}= C_n^2$ï¼›        
å¯¹äºæœ‰å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX} = 2*C_n^2 = P_n^2$

- **adjacent** : ç›¸é‚»çš„
![[adjacent.png]]

- **Subgraph** : $G'\subset G\ if\ and\ only\ if\ V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$

- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}\ such\ that\ (v_p, v_{i1}),(v_{i1}, v_{i2}),..., (v_{in}, v_q)\ or\ <v_p, v_{i1}>,<v_{i1}, v_{i2}>,..., <v_{in}, v_q>\ belong\ to\ E(G)$

- **Length of Path** : pathä¸­è¾¹çš„ä¸ªæ•°(æ³¨æ„ï¼Œæ˜¯è¾¹)

- **Simple Path** : è·¯å¾„æ²¡æœ‰é‡å¤çš„ç‚¹(ä¸åŒ…æ‹¬é¦–å°¾)

- **Circle** : é¦–å°¾ç›¸åŒçš„path

- **(Connected) Component of an undirected G** : æœ€å¤§çš„connected subgraph

- **A tree** : a graph that is connected and acyclic 

- **A DAG** : a directed acyclic graph ä¸€ä¸ªæœ‰æ–¹å‘çš„ä¸æˆåœ†çš„å›¾ï¼Œä¹Ÿå°±æ˜¯ä»»æ„ç»“ç‚¹éƒ½æ— æ³•é€šè¿‡ä¸€äº›æœ‰å‘è¾¹å›åˆ°è‡ªèº«

- **Strongly Connected** : å¯¹äºæ¯ä¸€å¯¹$v_i\ v_j$ï¼Œéƒ½åˆ†åˆ«å­˜åœ¨ä»$v_i\ to\ v_j\ ä»¥åŠ\ v_j\ to\ v_i$çš„directed path

- **Weakly Connected** : ä¸ä¸Šé¢ç›¸åŒï¼Œä½†æ˜¯æ˜¯æ— æ–¹å‘å›¾ä¸­ï¼ˆç›´æ¥å°†æœ‰æ–¹å‘å›¾çœ‹ä½œæ— æ–¹å‘å›¾ï¼‰

- **Degree(v)** : ä¸vç›¸è¿çš„è¾¹çš„ä¸ªæ•°ï¼›å¦‚æœæ˜¯æœ‰æ–¹å‘å›¾ï¼Œåˆ™ç”¨in-degreeè¡¨ç¤ºæŒ‡å‘vçš„è¾¹çš„ä¸ªæ•°ï¼Œout-degreeè¡¨ç¤ºä»væŒ‡å‡ºçš„è¾¹çš„ä¸ªæ•°ã€‚
ä¹Ÿå› æ­¤å¯ä»¥å¾—åˆ°è¾¹çš„æ€»æ•°ä¸ºdegree(v)çš„å’Œçš„ä¸€åŠ(ä¸€æ¡è¾¹ç”±ä¸¤ä¸ªvertexå…±æœ‰)

- **topological order** : æ‹“æ‰‘åºï¼Œa linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.

### AOV network (Active on vertices)

åœ¨Digraphä¸­ï¼Œç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨æœ‰å‘è¾¹$<v_{i}, v_{j}>$è¡¨ç¤ºæ´»åŠ¨ i æ˜¯æ´»åŠ¨ j çš„å¿…é¡»æ¡ä»¶ã€‚è¿™ç§æœ‰å‘å›¾ç§°ä¸ºç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œï¼Œå³AOV networkã€‚

æ ¹æ®å®šä¹‰ï¼Œä¸€ä¸ªå¯è¡Œçš„AOV networkå¿…é¡»æ˜¯DAG (directed acyclic graph)ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†æ‹“æ‰‘åºã€‚

### åˆ¤æ–­åºåˆ—Seqæ˜¯å¦æ˜¯æ‹“æ‰‘åº

åœ¨å®æˆ˜ä¸­å°½é‡ç”¨æ•°ç»„è¡¨ç¤ºå§ï¼Œç”¨é“¾è¡¨è¿æ¥å†™çš„çƒ‚å®Œäº†ğŸ˜‚


```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYDå‘½åå¤ªæ··ä¹±äº†ï¼Œè®°ä¸ªæ€è·¯å°±è¡Œ

/*
*æ¯æ¬¡å¾ªç¯å°†ä»Seq[i]outçš„edgeå½’é›¶
*ä¿®æ­£ï¼šä¸ç”¨å½’é›¶ï¼Œå› ä¸ºä¹‹åå°±ä¸ä¼šè°ƒç”¨Seq[i]å¯¹åº”çš„Vertexäº†
*å¹¶ä¸”å½’é›¶å‰æ£€æµ‹ä¸€éå®ƒæŒ‡å‘çš„å…ƒç´ æ˜¯å¦åœ¨Seq[i]å‰é¢ï¼Œ
*è‹¥åœ¨è¯´æ˜falseï¼Œæœ€åéƒ½æ²¡falseå°±true
*/
```

```C
//HWä¸­çš„å®ç°
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[MaxVertexNum]; //AdjList[i]ä¸­å­˜ç¬¬iä¸ªvertexçš„out edgeé“¾è¡¨

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;

LGraph G=ReadG();
```


### Network Flow Problems ç½‘ç»œæœ€å¤§æµé—®é¢˜

![[NetworkFlowé—®é¢˜.png]]

ç»™å®šä¸€ä¸ªgraphï¼Œç¡®å®šå¤´sä»¥åŠå°¾tï¼Œæ±‚ä»såˆ°tå…±æœ‰å¤šå°‘flowå¯ä»¥è¿›å…¥

[è§£å†³æ–¹æ³•](#)

$G_fï¼šæµé‡å›¾\ \ G_rï¼šä½™é‡å›¾\ \ ï¼Œåˆå§‹æ—¶G_fä¸ºç©ºï¼ŒG_rå’ŒGç›¸åŒ$

1. é€‰æ‹©è·¯å¾„ï¼šåœ¨å›¾$G_r$ä¸­ä»»æ„é€‰æ‹©ä¸€æ¡æºç‚¹åˆ°ç›®æ ‡ç‚¹çš„è·¯å¾„
2. æ›´æ–°$G_f$ï¼šåœ¨$G_f$ä¸­æ·»åŠ è¯¥è·¯å¾„ï¼Œè·¯å¾„çš„å¤§å°ç”±æœ€å°æµé‡å†³å®š
3. æ›´æ–°$G_r$ï¼šå¦‚æœè·¯å¾„çš„ä¸€éƒ¨åˆ†ä¸º $a->b$ æ•´æ¡è·¯å¾„æœ€å°æµé‡ä¸ºqï¼Œ$a->b$çš„æœ¬èº«æµé‡ä¸ºpï¼Œåˆ™$G_r$ä¸­æ·»åŠ $b->a$ï¼Œæµé‡ä¸ºqï¼Œ$a->b$çš„æµé‡æ›´æ–°ä¸ºp-q(å¦‚æœä¸º0åˆ™åˆ å»è¿™æ¡è·¯å¾„)
4. é‡å¤1ã€2ã€3ç›´åˆ°$G_r$ä¸­æ‰¾ä¸åˆ°è·¯å¾„

#### dfsç®—æ³•å®ç° Depth-First Search

```cpp
int n, m, s, t; // sæ˜¯æºç‚¹ï¼Œtæ˜¯æ±‡ç‚¹
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // åˆ°è¾¾ç»ˆç‚¹ï¼Œè¿”å›è¿™æ¡å¢å¹¿è·¯çš„æµé‡
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // è¿”å›çš„æ¡ä»¶æ˜¯æ®‹ä½™å®¹é‡å¤§äº0ã€æœªè®¿é—®è¿‡è¯¥ç‚¹ä¸”æ¥ä¸‹æ¥å¯ä»¥è¾¾åˆ°ç»ˆç‚¹ï¼ˆé€’å½’åœ°å®ç°ï¼‰
        // ä¼ é€’ä¸‹å»çš„æµé‡æ˜¯è¾¹çš„å®¹é‡ä¸å½“å‰æµé‡ä¸­çš„è¾ƒå°å€¼
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // è¿™æ˜¯é“¾å¼å‰å‘æ˜Ÿå–åå‘è¾¹çš„ä¸€ç§ç®€æ˜“çš„æ–¹æ³•
            // å»ºå›¾æ—¶è¦æŠŠcntç½®ä¸º1ï¼Œä¸”è¦ä¿è¯åå‘è¾¹ç´§æ¥ç€æ­£å‘è¾¹å»ºç«‹
            return c;
        }
    }
    return -1; // æ— æ³•åˆ°è¾¾ç»ˆç‚¹
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
```

#### bfsç®—æ³•å®ç° 

```cpp
int n, m, s, t, last[MAXN], flow[MAXN];
inline int bfs()
{
    memset(last, -1, sizeof(last));
    queue<int> q;
    q.push(s);
    flow[s] = INF;
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        if (p == t) // åˆ°è¾¾æ±‡ç‚¹ï¼Œç»“æŸæœç´¢
            break;
        for (int eg = head[p]; eg; eg = edges[eg].next)
        {
            int to = edges[eg].to, vol = edges[eg].w;
            if (vol > 0 && last[to] == -1) // å¦‚æœæ®‹ä½™å®¹é‡å¤§äº0ä¸”æœªè®¿é—®è¿‡ï¼ˆæ‰€ä»¥lastä¿æŒåœ¨-1ï¼‰
            {
                last[to] = eg;
                flow[to] = min(flow[p], vol);
                q.push(to);
            }
        }
    }
    return last[t] != -1;
}
inline int EK()
{
    int maxflow = 0;
    while (bfs())
    {
        maxflow += flow[t];
        for (int i = t; i != s; i = edges[last[i] ^ 1].to) // ä»æ±‡ç‚¹åŸè·¯è¿”å›æ›´æ–°æ®‹ä½™å®¹é‡
        {
            edges[last[i]].w -= flow[t];
            edges[last[i] ^ 1].w += flow[t];
        }
    }
    return maxflow;
}
```

### Minimum Spanning Tree æœ€å°ç”Ÿæˆæ ‘

[å®šä¹‰](#)
ä¸€ä¸ªè¿é€šå›¾çš„ç”Ÿæˆæ ‘æ˜¯ä¸€ä¸ªæå°çš„è¿é€šå­å›¾ï¼Œå®ƒåŒ…å«å›¾ä¸­æ‰€æœ‰nä¸ªé¡¶ç‚¹ï¼Œä½†åªæœ‰æ„æˆä¸€æ£µæ ‘çš„n-1æ¡è¾¹ã€‚

æ‰€è°“ä¸€ä¸ª**å¸¦æƒå›¾**çš„==æœ€å°ç”Ÿæˆæ ‘==ï¼Œå°±æ˜¯å›¾ä¸­**è¾¹çš„æƒå€¼å’Œæœ€å°çš„ç”Ÿæˆæ ‘**ã€‚


[å±æ€§](#)

- ä¸€ä¸ªå›¾å¯ä»¥æœ‰å¤šä¸ªç”Ÿæˆæ ‘(==ä¹Ÿå¯ä»¥æœ‰å¤šä¸ªæœ€å°ç”Ÿæˆæ ‘==)
- å¯¹äºåŒ…å«nä¸ªé¡¶ç‚¹çš„æ— å‘å®Œå…¨å›¾æœ€å¤šåŒ…å«$n^{n-2}$é¢—ç”Ÿæˆæ ‘ã€‚
- ç”Ÿæˆæ ‘ä¸­ä¸å­˜åœ¨ç¯
- ç§»é™¤ç”Ÿæˆæ ‘çš„ä»»æ„ä¸€æ¡è¾¹éƒ½ä¼šå¯¼è‡´å›¾çš„ä¸è¿é€š
- åœ¨ç”Ÿæˆæ ‘ä¸­ä»»æ„æ·»åŠ ä¸€æ¡è¾¹éƒ½ä¼šæ„æˆç¯

#### Primç®—æ³•

1. ä»»æ„é€‰æ‹©ä¸€ä¸ªç‚¹ï¼ŒåŠ å…¥ç”Ÿæˆæ ‘(å·²ç»ç”Ÿæˆçš„éƒ¨åˆ†)
2. é€‰æ‹©ä¸è¿™ä¸ªç‚¹ç›¸è¿çš„æƒå€¼æœ€å°çš„è¾¹å’Œç‚¹åŠ å…¥åˆ°ç”Ÿæˆæ ‘
3. å¯¹äºå·²ç»ç”Ÿæˆçš„éƒ¨åˆ†ï¼Œå†æ¬¡é‡å¤2
4. å½“æ‰€æœ‰ç‚¹åŠ å…¥åï¼Œåœæ­¢

#### Kruskalç®—æ³•

1. é€‰æ‹©æƒå€¼æœ€å°çš„è¾¹åŠä¸å®ƒç›¸è¿çš„ç‚¹åŠ å…¥ç”Ÿæˆæ ‘
2. ä»åŸå›¾ä¸­åˆ å»è¿™æ¡è¾¹
3. é€‰å–æƒå€¼æœ€å°çš„ä¸”ä¸æ„æˆCircleçš„è¾¹å’Œç‚¹åŠ å…¥ç”Ÿæˆæ ‘(==ä¸è¦æ±‚å’Œå·²ç»ç”Ÿæˆçš„éƒ¨åˆ†ç›¸è¿==)
4. ä»åŸå›¾ä¸­åˆ å»è¿™æ¡è¾¹
5. é‡å¤3ã€4ç›´åˆ°åŒ…å«æ‰€æœ‰ç‚¹

åœ¨ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘MSTçš„æ—¶å€™ï¼Œå¯ä»¥é‡‡ç”¨==å¹¶æŸ¥é›†==çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤ºè¾¹çš„è¿æ¥å…³ç³»ã€‚


