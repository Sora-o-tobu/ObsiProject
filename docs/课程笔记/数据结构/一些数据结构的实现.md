# ä¸€äº›æ•°æ®ç»“æ„çš„å®ç°
## é“¾è¡¨çš„åˆ›å»ºä¸æ·»åŠ èŠ‚ç‚¹

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(Polynomial)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

## æ ˆçš„åˆå§‹åŒ–

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

### ä»¥é“¾è¡¨çš„æ–¹å¼å®ç°æ ˆ

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp çš„ä½œç”¨å°±æ˜¯é‡Šæ”¾ç©ºé—´
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

## ä»¥é“¾è¡¨çš„æ–¹å¼å®ç°é˜Ÿåˆ—

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

## æ ‘

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

### ä»ä¸­åºéå†å’Œååºéå†å¾—åˆ°ä¸€ä¸ªäºŒå‰æ ‘

```c
Tree newnode(int data);
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N);
int main(void){
    int N;scanf("%d",&N);int inorder[N],postorder[N];
    for(int i=0;i<N;i++){
        scanf("%d",inorder+i);
    }
    for(int i=0;i<N;i++){
        scanf("%d",postorder+i);
    }Tree head=newnode(postorder[N-1]);
    createTree(head,inorder,postorder,0,N,N);
}
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N){
    Tree temp;
    int z;
    if(front>=rear){
        return NULL;
    }
    int indexh=Find(postorder[rear-1],inorder,0,N);
    int index=front-1;
    for(int i=rear-2;i>=front;i--){
        z=Find(postorder[i],inorder,0,N);
        if(z<indexh){
            index=i;
            break;
        }
    }if(rear-2<front){
        return NULL;
    }
    if(index==front-1){
        head->left=NULL;
        temp=newnode(postorder[rear-2]);
        head->right=temp;
    }else if(index==rear-2){
        head->right=NULL;
        temp=newnode(postorder[index]);
        head->left=temp;
    }else{
        temp=newnode(postorder[rear-2]);
        head->right=temp;
        temp=newnode(postorder[index]);
        head->left=temp;
    }if(head->left!=NULL)
    createTree(head->left,inorder,postorder, front,index+1,N);
    if(head->right!=NULL)
    createTree(head->right,inorder,postorder,index+1,rear-1,N);
}
/*è‹¥æ˜¯æƒ³è¦ä»¥zigzagging orderè¾“å‡ºçš„è¯ï¼Œå»ºç«‹ä¸¤ä¸ªæ ˆï¼Œç¬¬ä¸€ä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¾æ¬¡å°†å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹å‹å…¥ç¬¬äºŒä¸ªæ ˆä¸­ï¼›
 *ç¬¬äºŒä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¸€æ¬¡å°†å³èŠ‚ç‚¹å’Œå·¦èŠ‚ç‚¹å‹å…¥ç¬¬ä¸€ä¸ªæ ˆä¸­ï¼Œæ¯ä¸ªæ ˆç©ºäº†ä¹‹åè½®æ¢åˆ°ä¸‹ä¸€ä¸ªæ ˆ
 */
```

## å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰Priority Queue

```c
typedef struct HeapStruct *PriorityQueue;
struct HeapStruct {
    ElementType  *Elements;
    int Capacity;
    int Size;
};
// å…¶å®æ›´å¤šä»¥æ•°ç»„çš„æ–¹å¼å®ç° å·¦å­æ ‘ï¼š2*index å³å­æ ‘ 2*index+1 çˆ¶èŠ‚ç‚¹ index/2
// æ³¨æ„ï¼Œæœ‰ä¸ªdummy headï¼Œæ ¹èŠ‚ç‚¹ä»index = 1å¼€å§‹
```


æ³¨æ„ï¼Œd-heapæŒ‡ä¸€ä¸ªèŠ‚ç‚¹æœ‰dä¸ªå­©å­ï¼ˆå½“ç„¶è¿˜æ˜¯å®Œå…¨æ ‘å“¦~ï¼‰
```c
child(i,j) = d*(i-1)+2+j    (iæ˜¯çˆ¶äº²ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œjæ˜¯ç¬¬å‡ ä¸ªå„¿å­ï¼ŒèŒƒå›´æ˜¯0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (è¿™æ˜¯d-heapæœ€åä¸€ä¸ªæœ‰å¶å­çš„ç»“ç‚¹ã€‚åœ¨heapé‡Œæ˜¯size()/2)
```

## Union & Find

ç­‰ä»·å…³ç³»**R**çš„ä¸‰ä¸ªæ€§è´¨:
- **Reflexive** è‡ªåæ€§ï¼š
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** å¯¹ç§°æ€§:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** ä¼ é€’æ€§ï¼š
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

> æ³¨æ„:
> å¦‚æœè¦ç»™é•¿åº¦ä¸ºNçš„Union(æ•°ç»„å®ç°)ä»˜åˆå€¼(å³å…¨ä¸º-1)ï¼Œä¸èƒ½é‡‡ç”¨å¦‚ä¸‹å†™æ³•:
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *å®é™…ä¸Šuni[N+1] = {0};ä¹Ÿæ˜¯ä¸å…è®¸çš„ï¼Œæ•°ç»„é•¿åº¦ä¸ºå˜é‡çš„è¯ä¸èƒ½èµ‹åˆå€¼ï¼›
    *å†µä¸”è¿™é‡Œå†™-1æœ€å¤šä¹Ÿåªèƒ½æŠŠç¬¬ä¸€ä¸ªèµ‹ä¸º-1ï¼ˆå³ä¸º-1,0,0,0,...ï¼‰
    */
    --- --- --- --- ---
    //æ­£ç¡®å†™æ³•å¦‚ä¸‹:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){ //è¿™é‡Œæ—¶é—´å¤æ‚åº¦ä¸ºO(N) ï¼Œå°†æ•´ä¸ªä»£ç éƒ½æ‹‰è·¨äº†ï¼Œæœ‰ä»€ä¹ˆåŠæ³•å‘¢ï¼Ÿ
        uni[i]=-1;
    }
```


```C
//ä¼˜åŒ–è¿‡çš„findç®—æ³•ï¼Œæ‰¾rootçš„æ—¶å€™é¡ºä¾¿å‡å°‘äº†depth
//é€’å½’ç‰ˆæœ¬
SetType Find ( ElementType X , DisjSet S ){

if ( S[ X ] <= 0 )
	return X;
else 
	return S[ X ] = Find( S[ X ], S );
}
```

```c
//è¿­ä»£ç‰ˆæœ¬
SetTypeÂ  Find ( ElementTypeÂ  X, DisjSetÂ  S ){Â Â  
	ElementTypeÂ  root,Â  trail,Â  lead;

Â Â Â  for ( root = X; S[ root ] > 0; root = S[ root ] );Â  // find the root
Â Â Â  for ( trail = X; trail != root; trail = lead ) {
Â Â Â Â Â Â  lead = S[ trail ] ;Â Â 
Â Â Â Â Â Â  S[ trail ] = root ;Â Â 
Â Â Â  }Â  //æŠŠè·¯ä¸Šé‡åˆ°çš„èŠ‚ç‚¹å…¨è¿æ¥åˆ°rootä¸Š
Â Â Â  returnÂ  root ;
}
```

```c
void SetUnion(ElementType n1, ElementType n2, DisjSet S){
	Element root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
```


## Graph å›¾

#### Definition
- **G(V,E)**  : Gä»£è¡¨å›¾ï¼ŒVä»£è¡¨finite nonempty set of vertices(vertexçš„å¤æ•°ï¼Œé¡¶ç‚¹)ï¼ŒEä»£è¡¨finite set of edges

- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$

- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$

- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.

- **Complete Graph** : è¾¹æ•°æœ€å¤§çš„graph 
å¯¹äºæ— å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX}= C_n^2$ï¼›        
å¯¹äºæœ‰å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX} = 2*C_n^2 = P_n^2$

- adjacent : ç›¸é‚»çš„
![[adjacent.png]]

- **Subgraph** : $G'\subset G\ if\ and\ only\ if\ V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$

- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}\ such\ that\ (v_p, v_{i1}),(v_{i1}, v_{i2}),..., (v_{in}, v_q)\ or\ <v_p, v_{i1}>,<v_{i1}, v_{i2}>,..., <v_{in}, v_q>\ belong\ to\ E(G)$

- **Length of Path** : pathä¸­è¾¹çš„ä¸ªæ•°(æ³¨æ„ï¼Œæ˜¯è¾¹)

- **Simple Path** : è·¯å¾„æ²¡æœ‰é‡å¤çš„ç‚¹(ä¸åŒ…æ‹¬é¦–å°¾)

- **Circle** : é¦–å°¾ç›¸åŒçš„path

- **(Connected) Component of an undirected G** : æœ€å¤§çš„connected subgraph

- **A tree** : a graph that is connected and acyclic 

- **A DAG** : a directed acyclic graph ä¸€ä¸ªæœ‰æ–¹å‘çš„ä¸æˆåœ†çš„å›¾

- **Strongly Connected** : å¯¹äºæ¯ä¸€å¯¹$v_i\ v_j$ï¼Œéƒ½åˆ†åˆ«å­˜åœ¨ä»$v_i\ to\ v_j\ ä»¥åŠ\ v_j\ to\ v_i$çš„directed path

- **Weakly Connected** : ä¸ä¸Šé¢ç›¸åŒï¼Œä½†æ˜¯æ˜¯æ— æ–¹å‘å›¾ä¸­ï¼ˆç›´æ¥å°†æœ‰æ–¹å‘å›¾çœ‹ä½œæ— æ–¹å‘å›¾ï¼‰

- **Degree(v)** : ä¸vç›¸è¿çš„è¾¹çš„ä¸ªæ•°ï¼›å¦‚æœæ˜¯æœ‰æ–¹å‘å›¾ï¼Œåˆ™ç”¨in-degreeè¡¨ç¤ºæŒ‡å‘vçš„è¾¹çš„ä¸ªæ•°ï¼Œout-degreeè¡¨ç¤ºä»væŒ‡å‡ºçš„è¾¹çš„ä¸ªæ•°ã€‚
ä¹Ÿå› æ­¤å¯ä»¥å¾—åˆ°è¾¹çš„æ€»æ•°ä¸ºdegree(v)çš„å’Œçš„ä¸€åŠ(ä¸€æ¡è¾¹ç”±ä¸¤ä¸ªvertexå…±æœ‰)

- **topological order** : æ‹“æ‰‘åºï¼Œa linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.


åœ¨å®æˆ˜ä¸­å°½é‡ç”¨æ•°ç»„è¡¨ç¤ºå§ï¼Œç”¨é“¾è¡¨è¿æ¥å†™çš„çƒ‚å®Œäº†ğŸ˜‚

```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYDå‘½åå¤ªæ··ä¹±äº†ï¼Œè®°ä¸ªæ€è·¯å°±è¡Œ
/*
æ˜¯ä¸æ˜¯å¯ä»¥è¿™ä¹ˆæƒ³:
æ¯æ¬¡å¾ªç¯å°†ä»Seq[i]outçš„edgeå½’é›¶ï¼Œ
å¹¶ä¸”å½’é›¶å‰æ£€æµ‹ä¸€éå®ƒæŒ‡å‘çš„å…ƒç´ æ˜¯å¦åœ¨Seq[i]å‰é¢ï¼Œè‹¥åœ¨è¯´æ˜falseï¼Œæœ€åéƒ½æ²¡falseå°±true
*/
```

