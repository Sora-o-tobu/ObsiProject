# ä¸€äº›æ•°æ®ç»“æ„çš„å®ç°

## ADT : The Abbreviation of Abstract Data Type

## Sequential Linear List é¡ºåºå­˜å‚¨çº¿æ€§è¡¨

ç”¨æ•°ç»„è¡¨ç¤ºçº¿æ€§è¡¨çš„ä¼˜ç‚¹æ˜¯ä¾¿äºéšæœºå­˜å– **(æ‰€è°“éšæœºå­˜å–ï¼Œå°±æ˜¯é€šè¿‡é¦–åœ°å€å’Œå…ƒç´ çš„ä½åºå·å€¼å¯ä»¥åœ¨O(1)çš„æ—¶é—´å†…æ‰¾åˆ°æŒ‡å®šçš„å…ƒç´ )**

é¡ºåºè¡¨çš„ä¼˜ç‚¹æ˜¯**å­˜å‚¨å¯†åº¦**(å­˜å‚¨åˆ©ç”¨ç‡)é«˜

## Linked List é“¾è¡¨çš„åˆ›å»ºä¸æ·»åŠ èŠ‚ç‚¹

å•å‘é“¾è¡¨é€šå¸¸æœ‰ä¸ªdummy headï¼Œå› æ­¤å¤´æŒ‡é’ˆå­˜æ”¾çš„ä¸æ˜¯å¤´ç»“ç‚¹çš„å†…å®¹

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(PtrToNode)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

## Stack æ ˆ

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

### ä»¥é“¾è¡¨çš„æ–¹å¼å®ç°æ ˆ

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp çš„ä½œç”¨å°±æ˜¯é‡Šæ”¾ç©ºé—´
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

## Queue é˜Ÿåˆ—(é“¾è¡¨å®ç°æ–¹å¼)

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

## Tree æ ‘

ç”±äº$2n_2 + n_1 +1= n_2 +n_1+ n_0$ ï¼Œæ‰€ä»¥$n_2= n_0-1$ï¼Œåº¦ä¸º2çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºå¶ç»“ç‚¹ä¸ªæ•°å‡ä¸€

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree Left;
    Tree Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

### ä»ä¸­åºéå†å’Œååºéå†å¾—åˆ°ä¸€ä¸ªäºŒå‰æ ‘

```c
Tree newnode(int data);
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N);
int main(void){
    int N;scanf("%d",&N);int inorder[N],postorder[N];
    for(int i=0;i<N;i++){
        scanf("%d",inorder+i);
    }
    for(int i=0;i<N;i++){
        scanf("%d",postorder+i);
    }Tree head=newnode(postorder[N-1]);
    createTree(head,inorder,postorder,0,N,N);
}
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N){
    Tree temp;
    int z;
    if(front>=rear){
        return NULL;
    }
    int indexh=Find(postorder[rear-1],inorder,0,N);
    int index=front-1;
    for(int i=rear-2;i>=front;i--){
        z=Find(postorder[i],inorder,0,N);
        if(z<indexh){
            index=i;
            break;
        }
    }if(rear-2<front){
        return NULL;
    }
    if(index==front-1){
        head->left=NULL;
        temp=newnode(postorder[rear-2]);
        head->right=temp;
    }else if(index==rear-2){
        head->right=NULL;
        temp=newnode(postorder[index]);
        head->left=temp;
    }else{
        temp=newnode(postorder[rear-2]);
        head->right=temp;
        temp=newnode(postorder[index]);
        head->left=temp;
    }if(head->left!=NULL)
    createTree(head->left,inorder,postorder, front,index+1,N);
    if(head->right!=NULL)
    createTree(head->right,inorder,postorder,index+1,rear-1,N);
}
/*è‹¥æ˜¯æƒ³è¦ä»¥zigzagging orderè¾“å‡ºçš„è¯ï¼Œå»ºç«‹ä¸¤ä¸ªæ ˆï¼Œ
 *ç¬¬ä¸€ä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¾æ¬¡å°†å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹å‹å…¥ç¬¬äºŒä¸ªæ ˆä¸­ï¼›
 *ç¬¬äºŒä¸ªæ ˆå¼¹å‡ºé¡¶ç«¯åä¸€æ¬¡å°†å³èŠ‚ç‚¹å’Œå·¦èŠ‚ç‚¹å‹å…¥ç¬¬ä¸€ä¸ªæ ˆä¸­ï¼Œæ¯ä¸ªæ ˆç©ºäº†ä¹‹åè½®æ¢åˆ°ä¸‹ä¸€ä¸ªæ ˆ
 */
```


### çº¿ç´¢äºŒå‰æ ‘ Threaded

å»ºæ ‘çš„æ—¶å€™ï¼Œæ¯ä¸ªèŠ‚ç‚¹æ˜¯æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼ˆæŒ‡å‘ä¸€å·¦ä¸€å³ï¼‰çš„ï¼ŒNä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯2Nä¸ªæŒ‡é’ˆï¼Œä½†æ˜¯å®é™…ä¸Šä¸æ˜¯Nullçš„åªæœ‰N-1ä¸ªï¼Œå› ä¸ºé™¤äº†æ ¹éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘è¿™ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰N+1ä¸ªæŒ‡é’ˆæ²¡æœ‰ç”¨ï¼Œçº¿ç´¢äºŒå‰æ ‘å°±æ˜¯ä¸ºäº†è®©è¿™N+1ä¸ªèŠ‚ç‚¹æœ‰ç”¨ï¼ŒæŒ‡å‘çš„å°±æ˜¯ä½ çš„æ’åºæ–¹å¼ç»™å‡ºåï¼Œé‚£ä¸ªçº¿æ€§æ’åˆ—çš„â€œå‰é©±â€å’Œâ€œåé©±â€ï¼Œå·¦æŒ‡é’ˆæŒ‡å‘å‰é©±ï¼Œå³æŒ‡é’ˆæŒ‡å‘åé©±ã€‚

å› æ­¤å†™é€‰æ‹©é¢˜çš„æ—¶å€™å¯ä»¥å…ˆå°†éå†ï¼ˆæ— è®ºæ˜¯å‰åºè¿˜æ˜¯ååºè¿˜æ˜¯ä¸­åºï¼‰åˆ—å‡ºæ¥ï¼Œå†å°†è™šçº¿è¿ä¸Šå»ã€‚
![[çº¿ç´¢äºŒå‰æ ‘.png]]

## Priority Queue å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—

```c
typedef struct HeapStruct *PriorityQueue; //è®¾ä¸ºæŒ‡é’ˆå½¢å¼æ–¹ä¾¿ç›´æ¥åœ¨å‡½æ•°ä¸­ä¿®æ”¹å€¼
struct HeapStruct {
    int *Elements;
    int Capacity;
    int Size;
};
// å…¶å®æ›´å¤šä»¥æ•°ç»„çš„æ–¹å¼å®ç° å·¦å­æ ‘ï¼š2*index å³å­æ ‘ 2*index+1 çˆ¶èŠ‚ç‚¹ index/2
// æ³¨æ„ï¼Œæœ‰ä¸ªdummy headï¼Œæ ¹èŠ‚ç‚¹ä»index = 1å¼€å§‹
```


```c
PriorityQueue Initialize(int MaxElements){
	PriorityQueue H=(PriorityQueue)malloc(sizeof(struct HeapStruct));
	if(H==NULL)
		exit(1);
	H->Elements=(int*)malloc((MaxElements+1)*sizeof(int)); //ç•™ä¸€ä¸ªç©ºä½ç»™dummyhead
	if(H->Elements==NULL)
		exit(1);
	H->Capacity=MaxElements;
	H->Size=0;
	return H;
}
```

```c
void Insert(int X,Priority H){
	int i;
	if(isFull(H)){
		return;
	}
	for(i=++H->Size;H->Elements[i/2]>X;i/=2){ //minHeapçš„æƒ…å†µ
		H->Elements[i]=H->Elements[i/2];
	}H->Elements[i]=X;
}
```

### Deleteæ“ä½œ
```c
//è¿›è¡Œdeleteæ“ä½œï¼Œæ€è·¯æ˜¯åˆ é™¤æœ€å°å…ƒç´ ï¼Œå°†é˜Ÿå°¾å…ƒç´ ç§»è‡³rootå¤„ï¼Œå†ä¸‹æ»¤è‡³ç¬¦åˆè¦æ±‚
int DeleteMin(Priority H){
	int i,child;
	int MinElement,LastElement;
	if(isEmpty(H))
		return;
	MinElement=H->Elements[1];
	LastElement=H->Elements[H->Size--];
	for(i=1;i*2<=H->Size;i=child){
		child=i*2;
		if(child!=H->Size && H->Elements[child+1]<H->Elements[child])
			child++;
		if(LastElement>H->Elements[child])
			H->Elements[i]=H->Elements[child];
		else
			break;
	}
	H->Elements[i]=LastElement;
	return MinElement;
}
```

å¦‚æœä½ å·²ç»å®šä¹‰è¿‡äº†PercolateDownçš„å‡½æ•°ï¼Œä½ ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨æ¥å®Œæˆä¸Šè¿°DeleteMinæ“ä½œã€‚

```c
void PercolateDown(int p,PriorityQueue H){ //ä¸‹æ»¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸ºæ ‘çš„é«˜åº¦O(h)
    int min;
    while(2*p<=H->Size && 2*p+1<=H->Size){
        if(H->Elements[2*p]<H->Elements[2*p+1])
            min = 2*p;
        else
            min = 2*p+1;
        if(H->Elements[min]<H->Elements[H->Size+1]){
            H->Elements[p]=H->Elements[min];
            p=min;
        }else
            break;
    }//æ³¨æ„å¾ªç¯ç»“æŸåè¿˜è¦åŠ ä¸ªåˆ¤æ–­å·¦å­æ ‘æ˜¯å¦è¿˜å¯ä»¥downçš„æ“ä½œï¼Œå› ä¸ºCompleteTreeå³å­æ ‘å¯èƒ½ä¸å­˜åœ¨ã€‚
    if(2*p<=H->Size && H->Elements[2*p]<H->Elements[H->Size+1]){ /
        H->Elements[p]=H->Elements[2*p];
        p=p*2;
    }H->Elements[p]=H->Elements[H->Size+1];
}
void PercolateUp(int p,PriorityQueue H){
    int tmp;
    while(p/2>=1 && H->Elements[p/2]>H->Elements[p]){
        tmp=H->Elements[p/2];
        H->Elements[p/2] = H->Elements[p];
        H->Elements[p] = tmp;
        p=p/2;
    }
}

//å…·ä½“è°ƒç”¨å¦‚ä¸‹:
H->Size--;
PercolateDown(1,H);
```

### å»ºå †æ“ä½œ

**å¯¹äºæœªæˆå †çš„Heapï¼Œæˆ‘ä»¬ä¸€èˆ¬ä»$\lfloor \frac{n}{2} \rfloor$å¼€å§‹ä¸‹æ»¤ï¼Œå®Œæˆæ’åºï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦ä¸ºO(n)å“¦ã€‚**

$T=\sum_1^{h+1} 2^{h+1} -1 -2^h= 2^{h+1} -1-(h+1)=O(n)$

### d-heap

æ³¨æ„ï¼Œd-heapæŒ‡ä¸€ä¸ªèŠ‚ç‚¹æœ‰dä¸ªå­©å­ï¼ˆå½“ç„¶è¿˜æ˜¯å®Œå…¨æ ‘å“¦~ï¼‰
```c
child(i,j) = d*(i-1)+2+j    (iæ˜¯çˆ¶äº²ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œjæ˜¯ç¬¬å‡ ä¸ªå„¿å­ï¼ŒèŒƒå›´æ˜¯0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (è¿™æ˜¯d-heapæœ€åä¸€ä¸ªæœ‰å¶å­çš„ç»“ç‚¹ã€‚åœ¨heapé‡Œæ˜¯size()/2)
```

### å †æ’åº

åˆ©ç”¨æœ€å¤§å †æœ€å¤§çš„å…ƒç´ åœ¨æ ¹èŠ‚ç‚¹çš„æ€§è´¨ï¼Œå¯ä»¥å¯¹æ•°ç»„è¿›è¡Œæ’åºã€‚

å…·ä½“å®ç°åŸç†ä¸º:

- å…ˆå°†åˆå§‹çš„R[1,...,n]å»ºç«‹æˆæœ€å¤§å †ï¼Œæ­¤æ—¶æ˜¯æ— åºå †ï¼Œè€Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ ã€‚
- å†å°†å †é¡¶R[1]å’Œæœ€åä¸€ä¸ªå…ƒç´ R[n]äº¤æ¢ï¼Œç”±æ­¤å¾—åˆ°æ–°çš„æ— åºåŒºR[1,...,n-1]ä¸æœ‰åºåŒºR[n]ã€‚
- å°†æ— åºåŒºå†æ¬¡å»ºå †(åªç”¨å¯¹R[1]è¿›è¡Œä¸‹æ»¤æ“ä½œå³å¯)ï¼Œé‡å¤ä¸Šè¿°æ“ä½œã€‚
- ç›´åˆ°æ— åºåŒºåªå‰©ä¸‹æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¯ä»¥å¾—åˆ°é€’å¢åºåˆ—ã€‚
## Disjoint Set å¹¶æŸ¥é›†

ç­‰ä»·å…³ç³»**R**çš„ä¸‰ä¸ªæ€§è´¨:

- **Reflexive** è‡ªåæ€§ï¼š
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** å¯¹ç§°æ€§:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** ä¼ é€’æ€§ï¼š
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

ä¸€èˆ¬å°†rootçš„å€¼è®¾ä¸ºå…¶**æ ‘çš„å¤§å°çš„è´Ÿå€¼**

**å¦‚æœè¦ç»™é•¿åº¦ä¸ºNçš„Union(æ•°ç»„å®ç°)èµ‹åˆå€¼(å³å…¨ä¸º-1)ï¼Œä¸èƒ½é‡‡ç”¨å¦‚ä¸‹å†™æ³•:**
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *å®é™…ä¸Šuni[N+1] = {0};ä¹Ÿæ˜¯ä¸å…è®¸çš„ï¼Œæ•°ç»„é•¿åº¦ä¸ºå˜é‡çš„è¯ä¸èƒ½èµ‹åˆå€¼ï¼›
    *å†µä¸”è¿™é‡Œå†™-1æœ€å¤šä¹Ÿåªèƒ½æŠŠç¬¬ä¸€ä¸ªèµ‹ä¸º-1ï¼ˆå³ä¸º-1,0,0,0,...ï¼‰
    */
    --- --- --- --- ---
    //æ­£ç¡®å†™æ³•å¦‚ä¸‹:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){
    //è¿™é‡Œæ—¶é—´å¤æ‚åº¦ä¸ºO(N) ï¼Œå°†æ•´ä¸ªä»£ç éƒ½æ‹‰è·¨äº†ï¼Œæœ‰ä»€ä¹ˆåŠæ³•å‘¢ï¼Ÿ
        uni[i]=-1;
    }
```

### ä¼˜åŒ–Findç®—æ³• è·¯å¾„å‹ç¼©

```C
//ä¼˜åŒ–è¿‡çš„findç®—æ³•ï¼Œæ‰¾rootçš„æ—¶å€™é¡ºä¾¿å‡å°‘äº†depth
//é€’å½’ç‰ˆæœ¬
int Find ( int X , DisjSet S ){
	if ( S[ X ] <= 0 )
		return X;
	else 
		return S[ X ] = Find( S[ X ], S );
}
```

```c
//è¿­ä»£ç‰ˆæœ¬
intÂ  Find ( intÂ  X, DisjSetÂ  S ){Â Â  
	intÂ  root,trail,lead;

Â Â Â  for ( root = X; S[ root ] > 0; root = S[ root ] );Â  // find the root
Â Â Â  for ( trail = X; trail != root; trail = lead ) {
Â Â Â Â Â Â  lead = S[ trail ] ;Â Â 
Â Â Â Â Â Â  S[ trail ] = root ;Â Â 
Â Â Â  }Â  //æŠŠè·¯ä¸Šé‡åˆ°çš„èŠ‚ç‚¹å…¨è¿æ¥åˆ°rootä¸Š
Â Â Â  returnÂ  root ;
}
```

### åˆå¹¶ Union

```c
void SetUnion(int n1, int n2, int S){
	int root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
//æŒ‰è¿™ç§æ–¹å¼Unionçš„å¹¶æŸ¥é›†ï¼Œåˆ™ä»»ä½•èŠ‚ç‚¹çš„æ·±åº¦å‡ä¸ä¼šè¶…è¿‡$log_2 N$
```


## Graph å›¾

#### Definition
- **G(V,E)**  : Gä»£è¡¨å›¾ï¼ŒVä»£è¡¨finite nonempty set of vertices(vertexçš„å¤æ•°ï¼Œé¡¶ç‚¹)ï¼ŒEä»£è¡¨finite set of edges

- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$

- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$

- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.

- **Complete Graph** : è¾¹æ•°æœ€å¤§çš„graph 
å¯¹äºæ— å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX}= C_n^2$ï¼›        
å¯¹äºæœ‰å‘å›¾ï¼Œè‹¥V=nï¼Œåˆ™$E_{MAX} = 2*C_n^2 = P_n^2$

- **adjacent** : ç›¸é‚»çš„
![[adjacent.png]]

- **Subgraph** : $G'\subset G\ if\ and\ only\ if\ V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$

- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}\ such\ that\ (v_p, v_{i1}),(v_{i1}, v_{i2}),..., (v_{in}, v_q)\ or\ <v_p, v_{i1}>,<v_{i1}, v_{i2}>,..., <v_{in}, v_q>\ belong\ to\ E(G)$

- **Length of Path** : pathä¸­è¾¹çš„ä¸ªæ•°(æ³¨æ„ï¼Œæ˜¯è¾¹)

- **Simple Path** : è·¯å¾„æ²¡æœ‰é‡å¤çš„ç‚¹(ä¸åŒ…æ‹¬é¦–å°¾)

- **Circle** : é¦–å°¾ç›¸åŒçš„path

- **(Connected) Component of an undirected G** : æœ€å¤§çš„connected subgraph

- **A tree** : a graph that is connected and acyclic 

- **A DAG** : a directed acyclic graph ä¸€ä¸ªæœ‰æ–¹å‘çš„ä¸æˆåœ†çš„å›¾

- **Strongly Connected** : å¯¹äºæ¯ä¸€å¯¹$v_i\ v_j$ï¼Œéƒ½åˆ†åˆ«å­˜åœ¨ä»$v_i\ to\ v_j\ ä»¥åŠ\ v_j\ to\ v_i$çš„directed path

- **Weakly Connected** : ä¸ä¸Šé¢ç›¸åŒï¼Œä½†æ˜¯æ˜¯æ— æ–¹å‘å›¾ä¸­ï¼ˆç›´æ¥å°†æœ‰æ–¹å‘å›¾çœ‹ä½œæ— æ–¹å‘å›¾ï¼‰

- **Degree(v)** : ä¸vç›¸è¿çš„è¾¹çš„ä¸ªæ•°ï¼›å¦‚æœæ˜¯æœ‰æ–¹å‘å›¾ï¼Œåˆ™ç”¨in-degreeè¡¨ç¤ºæŒ‡å‘vçš„è¾¹çš„ä¸ªæ•°ï¼Œout-degreeè¡¨ç¤ºä»væŒ‡å‡ºçš„è¾¹çš„ä¸ªæ•°ã€‚
ä¹Ÿå› æ­¤å¯ä»¥å¾—åˆ°è¾¹çš„æ€»æ•°ä¸ºdegree(v)çš„å’Œçš„ä¸€åŠ(ä¸€æ¡è¾¹ç”±ä¸¤ä¸ªvertexå…±æœ‰)

- **topological order** : æ‹“æ‰‘åºï¼Œa linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.


åœ¨å®æˆ˜ä¸­å°½é‡ç”¨æ•°ç»„è¡¨ç¤ºå§ï¼Œç”¨é“¾è¡¨è¿æ¥å†™çš„çƒ‚å®Œäº†ğŸ˜‚

### åˆ¤æ–­åºåˆ—Seqæ˜¯å¦æ˜¯æ‹“æ‰‘åº

```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYDå‘½åå¤ªæ··ä¹±äº†ï¼Œè®°ä¸ªæ€è·¯å°±è¡Œ
/*
*æ¯æ¬¡å¾ªç¯å°†ä»Seq[i]outçš„edgeå½’é›¶ï¼ˆä¸ç”¨å½’é›¶ï¼Œå› ä¸ºä¹‹åå°±ä¸ä¼šè°ƒç”¨Seq[i]å¯¹åº”çš„Vertexäº†ï¼‰
*å¹¶ä¸”å½’é›¶å‰æ£€æµ‹ä¸€éå®ƒæŒ‡å‘çš„å…ƒç´ æ˜¯å¦åœ¨Seq[i]å‰é¢ï¼Œè‹¥åœ¨è¯´æ˜falseï¼Œæœ€åéƒ½æ²¡falseå°±true
*/
```

