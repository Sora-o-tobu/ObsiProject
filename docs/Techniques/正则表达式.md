
!!! quote "[测试正则表达式的网站](https://regex101.com/)，不过说实话有 AI 帮忙生成正则已经很够用了"

正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。

## 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

| 字符         | 描述                                                  |
| ---------- | --------------------------------------------------- |
| \[...\]    | 匹配`[...]`中的所有字符，例如`[aeiou]`就会把字符串中所有元音字母提取出来        |
| \[^...\]   | 匹配除了`[...]`中的所有字符，即`[...]`的补集                       |
| \[A-Z\]    | `[A-Z]`表示一个区间，匹配所有大写字母，同理可以有`[0-9a-zA-Z]`来匹配所有字母和数字 |
| .          | 匹配所有除换行符 (\\n,\\r) 外的所有单个字符，相当于`[^\n\r]`            |
| \[\\s\\S\] | \\s 所有空白符，包括换行；\\S 是非空白符，不包括换行，因此该语句也是匹配所有字符        |
| \\w        | 匹配数组、字母、下划线，等价于`[0-9a-zA-Z_]`                       |
| \\d        | 匹配任意一个阿拉伯数字，等价于`[0-9]`                              |

## 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符  | 描述                                                                                    |
| --- | ------------------------------------------------------------------------------------- |
| \cx | 匹配由x指明的控制字符。例如， `\cM` 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f  | 匹配一个换页符。等价于 `\x0c` 和 `\cL`。                                                           |
| \n  | 匹配一个换行符。等价于 `\x0a` 和 `\cJ`。                                                           |
| \r  | 匹配一个回车符。等价于 `\x0d` 和 `\cM`。                                                           |
| \s  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。                 |
| \S  | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。                                                       |
| \t  | 匹配一个制表符。等价于 `\x09` 和 `\cI`。                                                           |
| \v  | 匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`。                                                         |

## 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。

正则表达式的限定符有：


| 字符    | 描述                                                          |
| ----- | ----------------------------------------------------------- |
| *     | 匹配前面的表达式零次或多次，例如，`go*d`能够匹配`gd`和`goood`。`*`等价于`{0,}`        |
| +     | 匹配前面的表达式一次或多次。`*`等价于`{1,}`                                  |
| ?     | 匹配前面的表达式零次或一次，例如，`do(es)?`可以匹配`do`和`does`。`?`等价于`{0,1}`     |
| {n}   | n是一个非负整数，匹配确定的 n 次。例如，`o{2}`不能匹配`sob`中的`o`，但能匹配`good`中的`oo` |
| {n,}  | 顾名思义，指至少匹配 n 次                                              |
| {n,m} | 顾名思义，指最少匹配 n 次，最多匹配 m 次                                     |

!!! tip "限定符的贪婪性"
	`*`和`+`都是贪婪的，即它们会尽可能匹配最大的字符串，而当我们在其后面加上`?`可以实现非贪婪或最小匹配
	
	例如，对于同一个 html 标签 `<h1>Nimisora</h1>`
	
	- `<.*>` : `<h1>Nimisora</h1>`
	- `<.*?>` : `<h1>` and `</h1>`



!!! warning "还未编写完成，但是记住上面几点也差不多够日常使用了"

